{"./":{"url":"./","title":"1. 集合","keywords":"","body":"1. 集合 1.1 并查集 支持快速合并、查询的结构: 查询：find(x) 查询元素的集合编号 合并： arr[x] = find(y); 把x元素加入y所在集合 arr[find(x)] = find(y); 把x所在的集合并入y所在的集合 #include using namespace std; struct Dsu { // Disjoint Set Union int n; // 令arr[i]表示i元素所在集合的编号，集合根结点arr[root]=root unordered_map arr; // 记录各集合中的元素个数 unordered_map dit; Dsu(int n) : n(n), arr(unordered_map()), dit(unordered_map()) {} Dsu *add(int x) { if (0 != arr.count(x)) return this; arr.emplace(x, x); dit.emplace(x, 1); return this; } void merge(int x, int y) { int rX = find(x); int rY = find(y); if (rX == rY) return; // 启发式合并：将小集合并到大集合中 if (dit[rX] > dit[rY]) swap(rX, rY); arr[rX] = rY; dit[rY] += dit[rX]; dit.erase(rX); } int find(int x) { // 压缩路径，元素直接挂到集合根结点下 return arr[x] == x ? x : arr[x] = find(arr[x]); } }; "},"chapter2/2.线性表.html":{"url":"chapter2/2.线性表.html","title":"2. 线性表","keywords":"","body":"2. 线性表 2.1 动态数组 静态数组是一块固定长度的内存，通过首地址加地址偏移可以做到随机读写，但在指定位置插入或删除元素时需要对相关元素做移位。 动态数组是长度不固定的数组，通常是在容量到达某个阈值时，重新申请更大空间将现有数据写入，从而达到动态扩容的目的。 #include using namespace std; class Array { int *arr, capacity; int ap; void check() { if (ap 2.2 链表 链表是碎片化的小内存，不同碎片间维护了其他碎片的内存地址，只能顺序读取，但插入和删除元素时无需移动大量元素。 struct Node { int val; Node *next; } *p = new Node, *tmp; int main() { // 在p结点后插入结点 tmp = p->next; // 保存next结点 p->next = new Node; // 插入新结点 p->next->next = tmp; // 新结点链接上原后继结点链 // 删除p结点的后继结点 tmp = p->next; // 保存next结点 p->next = tmp->next; // 覆盖后继结点 delete tmp; // 释放内存 return 0; } 2.2.1 判断链表中是否存在环 Floyd环判定算法-快慢指针：定义指针slower、faster；slower每次走1步faster每次走2步，若存在slower==faster则存在环；（时间:O(n),空间:O(1)） 另外：若可以改变链表结构，可修改遍历过结点的next使其指向一个固定的地址，同样可在O(n)时间内判断是否存在环。 2.2.2 求链表中环的起点 当以上slower==faster情况出现后，把slower重置为链表起点，此时两指针每次都同样只走1步，再相遇的点即为环起点。 2.2.3 求链表中环的长度 当slower和faster首次相遇后，停住faster继续走slower并统计，再次相遇即可得环长度。 证明第二问中环起点的解法正确： 设链表总长S = 非环长m + 环长n；由于首次相遇时slower总长为S，faster为2S： 两式分别为：①S = m + A * n + k、②2*S = m + B*n +\b k 其中A、B为正整数； 两式相减得：③S = (B-A)*n，即S长为整数倍环长； 结合①③式得(m+k)为整数倍环长，代入①式得m = S - A*n - k， 也即m = C*n - k = (C-1)*n + (n-k)，显然有下次两指针相再遇位置即为环起点。 2.3 KMP匹配 朴素的匹配算法，依次匹配主串S和子串T的元素，一旦失败则主串下行子串回溯。 KMP算法，主串不回溯，而子串回溯时\"尽量\"不回溯到起点： 子串回溯数组构建：通过双坐标进行\"自我匹配\"过程 双串匹配过程：匹配失败时，子串通过next数组回溯一段距离继续匹配 #include #include using namespace std; // 查找子串t在主串s中的位置 int kmp(const char s[], const char t[]) { int sLen = (int)strlen(s), tLen = (int)strlen(t); int i, j; // 构建子串t的回溯数组next; next[0] = -1, j左(子串)i右(主串)，不断回溯子串j i = 0, j = -1; int* next = new int[tLen]{-1}; while (i > s >> t) { cout 2.4 字典树 字典树Trie用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。如下图: 路径1 -> 4 -> 8 -> 12表示字符串caa。 检索字符串 给出n个名字串，然后进行m次点名，每次需要回答“名字不存在”、“第一次点到该名字”、“已经点过这个名字”之一。 其中:1 ，所有字符串长度不超过50。 #include using namespace std; struct Trie { int node[500005][26], cnt; int ended[500005];// 标记某个节点是否可作为串终点 void add(string &s) { int parent = 0; for (int i = 0, ch; i > n; while (n--) { cin >> s; trie.add(s); } cin >> m; while (m--) { cin >> s; n = trie.find(s); switch (n) { case 0: cout 2.5 AC自动机 Automaton是以Trie的结构为基础，结合KMP的思想建立的，用于处理多模式匹配。 【TODO:待补充】 2.6 线段树 线段树可以在O(logN)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 TODO【待补充】 "},"chapter3/3.栈.html":{"url":"chapter3/3.栈.html","title":"3. 栈","keywords":"","body":"3. 栈 栈是FILO的线性结构。 3.1 出站序列判断 题目大意：N辆车依次进站，给出一个出站序列，判断是否可行（车站容量>N)。 遍历出站序列，依次考虑入站队头和栈顶序号： 入站队头号 入站队头号 > 目标序列出站号：若此时栈顶元素和出站序列元素相等，则弹出；否则标记出站序列不可行。 #include #include using namespace std; int main() { int n, out, in = 1; bool ok = true; stack stk; cin >> n; // N个元素依次进站 while (n--) { cin >> out; // 当前已经不合法了，只接受输入 if (!ok) continue; // 判断 出站序号 和 进站序号 if (in 3.2 十进制转R进制 十转R进制：整数部分『除R逆取余』，小数部分『乘R顺取整』: 从高位到低位依次除以R，商保留，余数入栈。 把第一步的商作为被除数，继续上面步骤直到商为0； 余数出栈，得R进制整数。 字符串除数模拟竖式除法计算，将余数压入栈中。 #include #include using namespace std; int main() { char num[101], res[101]; int i, j, mod, rad; stack stk; // 输入大数 与 进制值R cin >> num >> rad; while (true) { mod = i = j = 0; // 模拟竖式除法:从高位到低位依次取被除数 while (0 != num[i]) { mod = mod * 10 + num[i++] - '0'; // 如果当前值tmp除以R有非前导零的商，则记录到res中 if (mod / rad > 0 || (mod / rad == 0 && j > 0)) { res[j++] = (char) (mod / rad + '0'); } mod %= rad; } // 余数压入栈中 stk.emplace(mod); // 如果没有商了，终止除法 if (j == 0) break; // 用商做被除数 for (int k = 0; k 9) { cout 3.3 双栈求表达式 中缀式转后缀式 加括号：按运算次序加括号：((a+(b*c)) + (((d*e)+f)*g)) 移符号：将运算符移到括号的后：((a(bc)*)+(((de)*f)+g)*)+ 去括号：得到后缀式：abc*+de*f+g*+；后缀式求值：遇到符号即计算。 双栈求中缀式值 对于含括号的混合运行，可先把中缀式转后缀式，然后再求后缀式的值。 规定优先级：)为最低优的0级、+-为1级、*/为2级、(为3级最高优。遍历输入串： 如果是数字，直接压入数字栈。 如果是符号，比较栈顶符号： 符号栈为空 或 当前符号优先于栈顶符号，符号【入栈】。 若当前符号低于栈顶优先级时： 若栈顶为最高优的左括号(： 当前是右括号)，栈顶左括号【出栈】。 当前为其他运算符，则当前运算符【入栈】。 栈顶为其他非左括号运算符，则栈顶更高优的运算符【出栈】，数字栈弹出2数运算后结果入数字栈。 表达式遍历完成后，清空符号栈计算得出最终结果。 #include #include #include using namespace std; // 获取符号优先级 int priority(char); // 计算二元式压入数字栈 void calc(stack &nStk, stack &oStk); int main() { char input[1000]; cin >> input; int i = 0, len = strlen(input), tmp; stack oStk; stack nStk; while (i = '0' && input[i] = '0' && input[i] priority(oStk.top())) { oStk.emplace(input[i++]); } else if (oStk.top() == '(') { // 栈顶符号优先级更高，为左括号时 if (input[i] == ')') { // 括号匹配直接弹出 oStk.pop(); } else { // 栈顶时左括号，当前为其他符号直接【入栈】 oStk.emplace(input[i]); } ++i; } else { // 栈顶非左括号 且 优先级更高，出栈计算 calc(nStk, oStk); } } // 清空符号栈，计算表达式 while (!oStk.empty()) calc(nStk, oStk); cout &nStk, stack &oStk) { char ch = oStk.top(); oStk.pop(); int y = nStk.top(); nStk.pop(); int &x = nStk.top(); switch (ch) { case '-': x = x - y; break; case '*': x = x * y; break; case '/': x = x / y; break; default: x = x + y; break; } } "},"chapter4/4.队列.html":{"url":"chapter4/4.队列.html","title":"4. 队列","keywords":"","body":"4. 队列 队列是FIFO的线性结构。 4.1 循环队列 容量为m，hp指向队头元素，tp指向队尾后一位的空位置（如[0, hp=1', 2', 3', tp=4, 5]）： 队列为空：hp == tp 队列已满：(tp + 1) % m == hp 队列长度：(tp - hp + M) % M 右移：(i + 1) % M 左移：(i - 1 + M) % M 约瑟夫环问题 题目大意: N个人编号1~N围成一圈，从1号开始数每数到X出列，之后从X+1继续数。求最后留在队列中的人的编号。 先把N个元素编号并依次进入队列 循环遍历模拟，直到队列中只剩下一个人。 #include using namespace std; int main() { int N, x, *queue, ap, cnt, c; cin >> N >> x; // 给M给人编号1~N queue = new int[N + 1]; for (int i = 0; i 1; ap = (ap + 1) % N) { if (!queue[ap]) continue; // 忽略已经移除的 // 数到X了，该成员出列 if (++c == x) { queue[ap] = 0; cnt--; c = 0; } } // 找到队列中没被剔除的编号 for (int i = 0; i 4.2 优先队列 基于堆结构(一棵完全二叉树)来实现优先级队列最直接、高效。 优先级队列可以用来实现高性能的多任务定时调度器。 #include #include #include using namespace std; void desc(); int main() { int n, i = 3, e; cin >> n; int *arr = new int[n + 4]{22, 16, 11}; make_heap(arr, arr + 3, greater<>()); // 初始化小根堆 while (n--) { cin >> e; arr[i++] = e; push_heap(arr, arr + i, greater<>()); // 插入元素后调整堆:尾元素上浮 } cout ()) = 1) { pop_heap(arr, arr + i, greater<>()); // 移除元素后调整堆: 根元素下沉 cout ()); // while (i > 0) cout 中封装有priority_queue堆适配器 priority_queue, less<>> q; int n, e; cin >> n; while (n--) { cin >> e; q.emplace(e); } while (!q.empty()) { cout "},"chapter5/5.树.html":{"url":"chapter5/5.树.html","title":"5. 树","keywords":"","body":"5. 树 树在有向无环图（DAG）的约束上再加了一个限制：任何一个结点只能有0或1个父结点。 而在二叉树中，任何一个结点最多只有两个子节点。 5.1 二叉树遍历 宽度优先搜索BFS 层序遍历，优先横向访问：从根结点开始依次把子结点加入队列中遍历。 #include using namespace std; struct Node { char ch; Node *l, *r; } *queue[100]; int ap = 0; void create(Node *&p); void bfs(Node *root); int main() { Node *root; // 以先序方式创建二叉树 create(root); // 借助队列宽度优先遍历 bfs(root); return 0; } void create(Node *&p) { char input; cin >> input; if (input == '#') { p = nullptr; } else { // 创建根结点 p = new Node; p->ch = input; // 构建左子树 create(p->l); // 构建右子树 create(p->r); } } void bfs(Node *root) { // 根结点加入队列 queue[ap++] = root; // 遍历当前队列中的结点 for (int i = 0; i ch; // 如果结点还有子结点，同样加入到队列中 if (queue[i]->l) { queue[ap++] = queue[i]->l; } if (queue[i]->r) { queue[ap++] = queue[i]->r; } } } 深度优先搜索DFS 盲目搜索，通常用于遍历数据（判断联通性），优先纵向访问：从根结点开始查找子结点到达叶子后回溯。 先序：ROOT-L-R 中序：L-ROOT-R 后序：L-R-ROOT #include using namespace std; struct Node { char data; Node *L, *R; }; void create(Node *&p); // 函数栈方式实现 先序遍历 void dfsProRecursively(Node *p); // 函数栈方式实现 中序遍历 void dfsMidRecursively(Node *p); // 函数栈方式实现 后序遍历 void dfsPosRecursively(Node *p); // 手工栈方式实现 先序遍历 void dfsProByStack(Node *p); // 手工栈方式实现 中序遍历 void dfsMidByStack(Node *p); // 手工栈方式实现 后序遍历 void dfsPosByStack(Node *p); int main() { Node *root = new Node; // 创建二叉树 create(root); dfsProRecursively(root); cout data; dfsProRecursively(p->L); dfsProRecursively(p->R); } void dfsProByStack(Node *p) { // 先序遍历：手工栈实现 // 创建栈 Node *stack[100]; int top = -1; // 结点指针非空 或 栈非空 while (p || top >= 0) { // 纵向搜索左子树，直到叶子 for (; p != nullptr; p = p->L) { // 纵向左搜过程先输出根节点 cout data; // 遍历后把根结点入栈 stack[++top] = p; } if (top != -1) { // 切换到子树 p = stack[top--]->R; } } } void dfsMidRecursively(Node *p) { // 中序遍历：函数递归栈实现 if (!p) return; dfsMidRecursively(p->L); cout data; dfsMidRecursively(p->R); } void dfsMidByStack(Node *p) { // 中序遍历：手工栈实现 Node *stack[100]; int top = -1; // 结点指针非空 或 栈非空 while (p || top >= 0) { // 纵向遍历左子树，结点先全部入栈 for (; p != nullptr; p = p->L) { stack[++top] = p; } if (top != -1) { // 输出栈顶数据（左子树）：当左子树未空或已访问时 p = stack[top--]; cout data; // 切换到右子树进行搜索 p = p->R; } } } void dfsPosRecursively(Node *p) { // 后序遍历：函数递归栈实现 if (!p) return; dfsPosRecursively(p->L); dfsPosRecursively(p->R); cout data; } void dfsPosByStack(Node *p) { // 后序遍历：手工栈实现 Node *stack[100]; int isVisR[100], top = -1; // 结点指针非空 或 栈非空 while (p || top != -1) { // 纵向搜索左子树，所有结点入栈 if (p) { stack[++top] = p; // 入栈后标记该结点右子树未访问 isVisR[top] = 0; p = p->L; } else { // 如果栈顶（根结点）右子树未访问，就先搜索右子树 if (!isVisR[top]) { p = stack[top]->R; // 并标记栈顶结点右子树已访问 isVisR[top] = 1; } else { // 输出栈顶结点数据：在左右子树都访问后 cout data; } } } } void create(Node *&p) { // 先序方式创建二叉树 char d; cin >> d; // 输入#结束 if (d == '#') { p = nullptr; return; } else { p = new Node; p->data = d; create(p->L); create(p->R); } } 5.2 二叉树重建 核心思想是：通过前/后序列的首尾元素(根结点)在中序序列中的位置，划分左右子树分治求解。即： 已知（先序，中序），求后序； 已知（后序，中序），求先序； #include #include using namespace std; // 重建先序序列 void rebuildProSeq(char *posSeq, char *midSeq, long len); // 重建后序序列 void rebuildPosSeq(char *proSeq, char *midSeq, long len); int main() { char proSeq[100] = \"1247536\"; char midSeq[100] = \"4725136\"; char posSeq[100] = \"7452631\"; rebuildProSeq(posSeq, midSeq, strlen(midSeq)); cout 5.3 线索二叉树 本质上是一种记忆化搜索：把树中空的子结点指针指向某种序列的前驱「L」后继「R」结点。 线索化后可以把树形结构压缩为扁平的链式结构，这样可以很便捷地找到某结点的前驱或后继结点（路由CIDR应用）。 前序线索树可以很方便找后继结点：左子树 > 右子树|后继线索。 后序线索树可以很方便找前驱结点：右子树 > 左子树|前驱线索。（逆序） 中序线索树找前驱结点和后继结点都方便： 找前驱结点：前驱线索 > 左子树的最右叶子。 找后继结点：后继线索 > 右子树的最左叶子。 #include using namespace std; struct Node { int data; bool isL2Child, isR2Child; Node *L, *R; Node() { data = 0; L = R = nullptr; } }; bool create(Node *&p); Node *lastP; // 线索化 void dfsProAndThreaded(Node *p); void dfsPosAndThreaded(Node *p); void dfsMidAndThreaded(Node *p); // 通过后继找先序 void dfsProByRClue(Node *headP); // 通过前驱找后序 void dfsPosByLClue(Node *headP); // 通过后继找中序 void dfsMidByRClue(Node *head); // 通过前驱找中序 void dfsMidByLClue(Node *head); // 1 2 4 0 7 0 0 5 0 0 3 0 6 0 0 int main() { Node *root, *headP; // ======================= 先序线索 ======================== create(root); lastP = headP = new Node; // 线索化 dfsProAndThreaded(root); // 得到顺序的先序遍历 lastP->R = headP; dfsProByRClue(headP); cout L = lastP; dfsPosByLClue(headP); cout R = headP; headP->L = lastP; dfsMidByRClue(headP); cout isR2Child) { lastP->R = p; } if (!p->isL2Child) { p->L = lastP; } // 访问当前结点 cout isL2Child data isR2Child isL2Child) { dfsProAndThreaded(p->L); } if (p->isR2Child) { dfsProAndThreaded(p->R); } } void dfsPosAndThreaded(Node *p) { if (!p) return; // 搜索子树 if (p->isL2Child) { dfsPosAndThreaded(p->L); } if (p->isR2Child) { dfsPosAndThreaded(p->R); } // 线索化 if (!lastP->isR2Child) { lastP->R = p; } if (!p->isL2Child) { p->L = lastP; } // 访问当前结点 cout isL2Child data isR2Child isL2Child) { dfsMidAndThreaded(p->L); } // 线索化 if (!lastP->isR2Child) { lastP->R = p; } if (!p->isL2Child) { p->L = lastP; } // 访问当前结点 cout isL2Child data isR2Child isR2Child) { dfsMidAndThreaded(p->R); } } void dfsProByRClue(Node *headP) { Node *p = headP->R; while (p != headP) { cout data; // 左子树 > 右子树,后继线索 if (p->isL2Child) { p = p->L; } else { p = p->R; } } } void dfsPosByLClue(Node *headP) { Node *p = headP->L; while (p != headP) { cout data; // 右子树 > 左子树,前驱线索 if (p->isR2Child) { p = p->R; } else { p = p->L; } } } void dfsMidByRClue(Node *head) { Node *p = head->R; while (p != head) { cout data; if (!p->isR2Child) { p = p->R; } else { // 后继线索 > 右子树的最左叶子 p = p->R; while (p->isL2Child) { p = p->L; } } } } void dfsMidByLClue(Node *head) { Node *p = head->L; while (p != head) { cout data; if (!p->isL2Child) { p = p->L; } else { // 前驱线索 > 左子树的最后叶子 p = p->L; while (p->isR2Child) { p = p->R; } } } } bool create(Node *&p) { int input; cin >> input; if (0 == input) { p = nullptr; return false; } p = new Node; p->data = input; p->isL2Child = create(p->L); p->isR2Child = create(p->R); return true; } 5.4 Haffman树 利用贪心策略，每次找到出现频率最低的结点，从下至上构建最优二叉树；这样得到的树总权重最小：sum(路径长*结点权)； Haffman树中，结点只有0或2个子树。 #include #include using namespace std; struct Node { int weight; char data; int L, R; bool hasParent; Node() { hasParent = false; L = R = -1; weight = data = 0; } }; // 找到权重最小的子树 int findMinWeightIndex(vector arr); // 先序方式遍历输出编码 void dfs(vector array, size_t index, vector pathStack); // 8 // a 5 b 29 c 7 d 8 e 14 f 23 g 3 h 11 int main() { int n; vector array; Node *node; // 输入统计数据 cin >> n; for (int i = 0; i > node->data >> node->weight; array.push_back(node); } // 构建Haffman树 for (int t = n; t > 1; t--) { int left = findMinWeightIndex(array); array[left]->hasParent = true; int right = findMinWeightIndex(array); array[right]->hasParent = true; node = new Node; node->L = left; node->R = right; node->weight = array[left]->weight + array[right]->weight; array.push_back(node); } dfs(array, array.size() - 1, vector()); return 0; } int findMinWeightIndex(vector arr) { int minWeight = -1, ans = -1; for (int i = 0; i hasParent) { continue; } else if (minWeight weight weight; ans = i; } } return ans; } void dfs(vector array, size_t index, vector pathStack) { if (index == -1) { return; } // 如果是叶子结点（Haffman树的子结点数只能是0或2） if (array[index]->L == -1) { cout data L, pathStack); // 右子树 pathStack.at(pathStack.size() - 1) = 1; dfs(array, array[index]->R, pathStack); pathStack.pop_back(); } 5.5 中缀表达式树 先扫描表达式构建中缀式树： 当前输入为数字直接构建叶子结点返回 当前非纯数字： 找到括号外优先级最低的运算符(最后计算的)，把串分成两部分分别构建。 若当前运算符都在括号内，则去掉两端括号继续构建。 后序遍历中缀式树，求出运算结果。 #include #include using namespace std; struct Node { int val; Node *L, *R; Node(int v) { val = v; L = R = nullptr; } }; // 判断串是否是数字 template bool isNumber(const string &str, T test); // 构造表达式树 Node *buildTree(const string &input); // 后序遍历求解 int posCalc(Node *node); int main() { // (1+2)*3-8/(2+2)*3 = 3 string input; cin >> input; cout bool isNumber(const string &str, T test) { istringstream sin(str); return sin >> test && sin.eof(); } Node *buildTree(const string &input) { if (isNumber(input, 0)) { // 纯数字表达式解析为叶子节点 int n = stoi(input); Node *node = new Node(n); return node; } // 找到优先级最低的运算符(后缀式最外层的运算符(最后执行运算)) int addOrSub = -1, multiOrDiv = -1, bracket = 0; for (int i = 0; i L = buildTree(input.substr(0, optIndex)); node->R = buildTree(input.substr(optIndex + 1)); return node; } int posCalc(Node *node) { // 后序遍历求解 if (nullptr == node) { return 0; } // 叶子结点说明是纯数字表达式 if (nullptr == node->L && nullptr == node->R) { return node->val; } // 非叶子结点需要计算 switch (node->val) { case '+': return posCalc(node->L) + posCalc(node->R); case '-': return posCalc(node->L) - posCalc(node->R); case '*': return posCalc(node->L) * posCalc(node->R); case '/': return posCalc(node->L) / posCalc(node->R); } return 0; } 5.6 平衡树 AVL树旋转 LL型右旋: 左子树转到根（根作为新的右子树，原右子树作为新右子树的左子树） RR型左旋：右子树转到根， LR型：先左旋再右旋 RL型：先右旋再左旋 红黑树 最坏情况下删除节点的复杂度为O(logN)，再平衡：改变颜色、单次左旋、单次右旋 结点为红色或黑色 Nil结点为黑色 红色结点的子结点必须为黑色 从根到Nil结点的每条路径上的黑色结点数相同 B树(B-Tree) B树属于多叉树，平衡多路查找树 所有结点的关键字按升序排列 非叶结点的子结点数(1, M] 枝结点关键字数[ceil(M/2)-1， M-1]；(结点关键字数 + 1 = 子结点指针数) 所有叶子结点均在同一层。 B+树 基于B树，但：查询速度更稳定、天然具备排序能力、全表扫描更快 非叶子结点只保存关键字索引，数据都放在叶子结点中。 叶结点关键字从小到大排序，且链接成串（左边结点结尾数据保存右边结点开始数据） 非叶子结点关键字数 = 子结点数 - 1 B*树 在B+树基础上，为非叶子结点也增加链表指针指向兄弟节点，将结点的最低利用率从1/2提高到2/3 "},"chapter6/6.图.html":{"url":"chapter6/6.图.html","title":"6. 图","keywords":"","body":"6. 图 6.1 图存储和遍历 图是由顶点的有穷非空集合和边的集合构成，表示为：G(V,E)。 对比项 线性表 树 图 数据元素 元素 结点 顶点 数据状态 可以是空表 可以是空树 顶点集不能为空，边集可以为空 数据关系 线性关系 层次关系 用边表示关系 存储方式： 邻接矩阵：G[i][j] 用来表示顶点i到顶点j是否邻接。 邻接表：G[i].vector 中保存了顶点i能邻接到的所有顶点：。 有向图无环图 DAG（Directed Acyclic Graph）： AOV网（Activity on Vertices)：有向图G中，用顶点表示活动，有向边表示活动Vi先于Vj发生。 AOE网（Activity on Edge)：有向图G中，边表示活动，边的权值表示活动持续时间，顶点V表示事件。 图的遍历 深度优先搜索：从起点出发遍历顶点（盲目搜索），可用来解决连通性、可达性问题。 #include using namespace std; bool vis[100]; int graph[100][100]; int dfs(int k, int n); // 9 // 0 6 4 5 0 0 0 0 0 // 0 0 0 0 1 0 0 0 0 // 0 0 0 0 1 0 0 0 0 // 0 0 0 0 0 2 0 0 0 // 0 0 0 0 0 0 9 7 0 // 0 0 0 0 0 0 0 4 0 // 0 0 0 0 0 0 0 0 2 // 0 0 0 0 0 0 0 0 4 // 0 0 0 0 0 0 0 0 0 int main() { int n; cin >> n; for (int i = 0; i > graph[i][j]; } } if (dfs(0, n) == n) { cout 宽度优先搜索：广度优先，同常用来解决 定长边的最短路径问题（迷宫最短路）、最小换乘问题。 #include #include using namespace std; const int N = 8; bool vis[N]; int g[N][N] = { {0, 2, 3, 0, 0, 0, 0, 9}, {2, 0, 0, 2, 4, 0, 0, 0}, {3, 0, 0, 1, 0, 0, 1, 1}, {0, 2, 1, 0, 0, 3, 1, 0}, {0, 4, 0, 0, 0, 2, 0, 0}, {0, 0, 0, 3, 2, 0, 1, 0}, {0, 0, 1, 1, 0, 1, 0, 2}, {9, 0, 1, 0, 0, 0, 2, 0} }; queue aQueue; // 迷宫最短路问题（路径定长） // 最小换乘问题 int main() { // 起点入队 vis[0] = true; aQueue.push(0); while (!aQueue.empty()) { int x = aQueue.front(); aQueue.pop(); cout 6.2 拓扑序 TOPO排序可以用来判断有向图中是否有环，TOPO序列是AOV中活动合理发生的顺序之一。 Kahn算法 本质上是BFS，复杂度O(v+e)： 选择一个入度为0的顶点v输出 去掉v的所有出边，再重复上一步。 DFS求TOPO序 判断是否是DAG，复杂度O(v): 顶点状态记录：0未访问，1访问中，2已访问 纵向搜索，如果找到访问中的顶点说明非DAG，否则即为DAG。 深度搜索找出TOPO序列，复杂度O(e)： 纵向搜索与当前顶点邻接且未访问的顶点 再把当前顶点压入栈中 顶点出栈即为TOPO序列 #include #include using namespace std; const int N = 9; int graph[N][N] = { {0, 6, 4, 5, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 2, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 9, 7, 0}, {0, 0, 0, 0, 0, 0, 0, 4, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 2}, {0, 0, 0, 0, 0, 0, 0, 0, 4}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, }; void kahn(); void dfs(); bool dfs4DAG(int k, int *vis); void dfs4Topo(int k, int *vis, vector &topo); int main() { // 深度搜索找TOPO序 dfs(); // 宽度搜索找TOPO序 kahn(); return 0; } void dfs() { int *vis = new int[N]{}; bool isDAG = true; // 先通过DFS判断是否是DAG：O(V) for (int i = 0; i topo; //遍历每个顶点 for (int i = 0; i &topo) { vis[k] = 1; // 找到一个没访问过，且 k->i 顶点 for (int i = 0; i aQueue; int visCnt = 0, t; // 初始化入度记录 O(V^2) for (int i = 0; i i的边去掉，则i的入度减1 for (int i = 0; i 6.3 最小生成树 生成树：包含N个结点，用最少边集保持图连通；即极小连通子图。 最小权重生成树：极小连通子图中，所有边的权重之和最小；通常用来解决最低代价连通问题（如多城市铺光缆问题）。 贪心策略： PRIM加点法：每次找到一个距离当前连通子图最近的顶点加入，直到所有顶点都在子图中。 KRUSKAL加边法：每次找到一个不属于同一子图的最短边连通两个子图，直达形成极小连通子图。 #include #include using namespace std; const int N = 8; bool vis[N]; int graph[N][N] = { {0, 2, 3, 0, 0, 0, 0, 9}, {2, 0, 0, 2, 4, 0, 0, 0}, {3, 0, 0, 1, 0, 0, 1, 1}, {0, 2, 1, 0, 0, 3, 1, 0}, {0, 4, 0, 0, 0, 2, 0, 0}, {0, 0, 0, 3, 2, 0, 1, 0}, {0, 0, 1, 1, 0, 1, 0, 2}, {9, 0, 1, 0, 0, 0, 2, 0} }; int prim(); int kruskal(); int main() { cout = 0 && graph[i][j] >= minWeight) { continue; } // 找到了一条连通两个不同子图，且权重最小的边 minWeight = graph[i][j]; x = i; y = j; } } if (x 6.4 Dijkstra Dijkstra算法用于求单源点到各点的最短距离，复杂度O(2*n^2)： dis[i]: 记录所有顶点到源点v的距离（不直接连通的置为MAX） k=min(dis[i])的i: 找到一个未访问过且距离起点最近的顶点k dis[i]=min(dis[i],dis[k]+g[k][i]: 刷新所有可以途径k到达的顶点的源点距离dis[i] 标记k为已访问，直达所有顶点都访问完毕，输出dis[i] 贪心策略： 每次都找源点所在子图外距离源点最近(min(dis[k]))的顶点加入子图，并时刻保持子图中顶点的源点距离dis[i]最小。(区别于最小生成树：距离子图最近，Dijkstra是：距离源点最近) #include using namespace std; const int N = 8; int graph[8][8] = { {0, 2, 3, 0, 0, 0, 0, 9}, {2, 0, 0, 2, 4, 0, 0, 0}, {3, 0, 0, 1, 0, 0, 1, 1}, {0, 2, 1, 0, 0, 3, 1, 0}, {0, 4, 0, 0, 0, 2, 0, 0}, {0, 0, 0, 3, 2, 0, 1, 0}, {0, 0, 1, 1, 0, 1, 0, 2}, {9, 0, 1, 0, 0, 0, 2, 0} }; bool vis[8]; // dis[i] 表示从起点到i顶点的距离 int dis[8]; void dijkstra(int v); int main() { dijkstra(0); for (int i = 1; i \" 0 && dis[i] > minDis) { continue; } minDis = dis[i]; k = i; } if (k = 0 && dis[i] k -> i 路径更短，则更新dis[i] dis[i] = dis[k] + graph[k][i]; } } } 6.5 Floyd Floyd算法用于求任意两点最短距离，复杂度O(n^3)： 初始化(i,j)距离：如不邻接则置为MAX 找到一个点k：如果(i,k,j) #include using namespace std; const int DIS_MAX = (1 x的距离置为0 for (int i = 0; i k>j) j) 则更新 for (int k = 0; k = 0 && dI2K2J 6.6 关键路径 寻找AOE网中的关键路径： 构造顶点（事件）的TOPO序列 事件的最早发生时间 = Max(前驱事件的最早发生时间 + 活动持续时间(边权重)) 事件的最晚发生时间 = Min(后继事件的最晚发生时间 - 活动持续时间) 活动的最早发生时间 = 前驱事件的最早发生时间 活动的最晚发生时间 = 后继事件的最晚发生时间 - 活动持续时间 关键活动：活动最早发生时间 == 活动最晚发生时间 #include #include #include #include using namespace std; const int N = 9; // AOE网: v表示事件, e表活动, 权值是活动持续时间; int graph[N][N] = { {0, 6, 4, 5, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 2, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 9, 7, 0}, {0, 0, 0, 0, 0, 0, 0, 4, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 2}, {0, 0, 0, 0, 0, 0, 0, 0, 4}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, }; // 顶点，表示事件 struct Vertex { // 顶点编号 int index; // 顶点的入度 int inDegree; // 最早发生时间 int earliest; // 最晚发生时间 int latest; Vertex() { index = 0; inDegree = 0; earliest = latest = -1; } }; // 边，表示活动 struct Edge { // 前驱事件，后继事件 int vPro, vPos; // 边权重：活动持续时间 int weight; // 最早发生时间 = 前驱事件最早发生时间 int earliest; // 最晚发生时间 = 后继事件最晚发生时间 - 活动持续时间 int latest; Edge(int pro, int pos, int w) { vPro = pro; vPos = pos; weight = w; earliest = latest = -1; } string toString() { return string(\"\"; } }; // 构造事件（点集）的TOPO序列 vector &buildVTopoSeq(); // 寻找关键活动（边集）：最早发生时间=最晚发生时间 vector &findKeyEdge(vector &edges, vector &vTopoSeq); int main() { vector edges; // 根据图初始化边集 for (int i = 0; i &vTopoSeq = buildVTopoSeq(); // 查询关键活动 vector &keyEdge = findKeyEdge(edges, vTopoSeq); // 输出所有关键活动 for (Edge *&x: keyEdge) { cout toString(); } return 0; } vector &buildVTopoSeq() { vector vertexes; for (int i = 0; i index = j; if (0 == graph[i][j]) { continue; } vertexes[j]->inDegree++; } } // 0入度顶点入队列 queue aQueue; for (int i = 0; i inDegree) { continue; } aQueue.push(vertexes[i]); } auto *topoSeq = new vector(); // BFS宽搜0入度顶点队列 Vertex *v; while (!aQueue.empty()) { v = aQueue.front(); aQueue.pop(); // 加入topo序列 topoSeq->push_back(v); // 清空v的出边并更新各顶点入度 for (int i = 0; i index][i]) { continue; } vertexes[i]->inDegree--; // 0入度加入队列 if (0 == vertexes[i]->inDegree) { aQueue.push(vertexes[i]); } } } return *topoSeq; } vector &findKeyEdge(vector &edges, vector &vTopoSeq) { // 构造事件的最早发生时间, 首事件的最早发生时间为0 vTopoSeq[0]->earliest = 0; // i事件最早发生的时间 = MAX(前驱事件最早发生时间 + 活动持续时间) // 顺取topo序列,vEarliest[i]=其先决活动都发生完毕 for (int i = 1; i earliest = -1; // 找出i的先决事件中完成最晚的 for (int k = 0; k earliest) { vTopoSeq[i]->earliest = vTopoSeq[k]->earliest + graph[k][i]; } else { vTopoSeq[i]->earliest = max(vTopoSeq[k]->earliest + graph[k][i], vTopoSeq[i]->earliest); } } } // 构造事件的最晚发生时间, 终事件的最晚发生时间等于其最早发生时间 vTopoSeq[vTopoSeq.size() - 1]->latest = vTopoSeq[vTopoSeq.size() - 1]->earliest; // i事件的最晚发生时间 = MIN(后继事件的最晚发生时间 - 活动持续时间) for (int i = (int) vTopoSeq.size() - 2; i >= 0; i--) { vTopoSeq[i]->latest = -1; for (int k = (int) vTopoSeq.size() - 1; k > i; k--) { if (!graph[i][k]) { continue; } if (-1 == vTopoSeq[i]->latest) { vTopoSeq[i]->latest = vTopoSeq[k]->latest - graph[i][k]; } else { vTopoSeq[i]->latest = min(vTopoSeq[k]->latest - graph[i][k], vTopoSeq[i]->latest); } } } auto *keyEdges = new vector(); // 更新活动最早和最晚发生时间，记录刻不容缓的活动：最早发生时间=最晚发生时间 for (auto &edge : edges) { // 活动i最早发生时间是其前驱事件最早开始时间 edge.earliest = vTopoSeq[edge.vPro]->earliest; // 活动i最晚发生时间是其后继事件最晚发生时间 - 活动持续时间 edge.latest = vTopoSeq[edge.vPos]->latest - edge.weight; // 关键活动：活动的最早发生时间 == 活动的最晚发生时间 if (edge.earliest == edge.latest) { keyEdges->push_back(&edge); } } return *keyEdges; } "},"chapter7/7.查找.html":{"url":"chapter7/7.查找.html","title":"7. 查找","keywords":"","body":"7. 查找 7.1 二分法 二分查找 二分查找基于关键字有序的条件下，每次匹配后将区分一分为二，查找查询复杂度logN。 #include using namespace std; // 递归方式 树深度：logN int dfsBSearch(const int *arr, int key, int left, int right); // 循环方式 int loopBSearch(const int *arr, int key, int left, int right); int main() { // 先决条件：关键字有序 int arr[10] = {12, 21, 23, 25, 54, 66, 75, 78, 95, 98}; int key = 12; cout = right) { return -1; } // 二分点，[left, right) int mid = left + (right - left) / 2; if (arr[mid] == key) { return mid; } // 搜索左区间 if (arr[mid] > key) { return dfsBSearch(arr, key, left, mid); } // 搜索右区间 if (arr[mid] key) { // 搜索左区间 right = mid; } else { // 搜索右区间 left = mid + 1; } } while (left 求根号2的近似值 求根号2的正近似值，精确到小数点后10位（float有效精度约6-7位，double有效精度约15-16位） 零点定理：若f(x)是单调的，且存在f(a) * f(b) , 则在(a, b)区间存在 X 使得 f(X) == 0; 题干转换：已知 x^2 = 2 , 求x在(0, 2)区间内的近似值。(sqrt(2)约等于1.414) #include #include using namespace std; double bSearch(double left, double right, int val); int main() { cout 0; mid在根的右边 if (mid * mid > val) { right = mid; } else { left = mid; } } while (right - left > 1E-10); return mid; } 快速幂 求x^y mod 10000007的值。 #define MOD 10000007 int pow(int x, int y) { if (y == 0) return 1; int t = pow(x, y / 2) % MOD; return (t * t * ((y & 1) ? x : 1)) % MOD; } 7.2 哈希 哈希算法的原理：将一个空间的数据集映射到另外一个更小的空间，并利用质数使数据集能够均匀的映射。 哈希函数 能够将任意长度的输入值转变成固定长度的值输出，该值称为散列值。 哈希函数设计需要考虑：均匀映射，减少冲突。 简单哈希处理 取余法：把关键字除以哈希表长度，余数作为哈希地址。 折叠法：将关键字分割成位数相同的几部分，取这几部分的叠加和做哈希地址。 平方取中法：求关键字的平方，取平方值的中间几位做哈希地址。 处理哈希冲突 开放地址法：为充分利用表空间，可以在冲突后以一种固定序列(可以是固定随机序列)去探测其他地址直到找到空位。 线性探测：hash(x) + i、hash(x) + (i+1)。 二次探测：hash(x) + i^2，hash(x) - i^2。 链地址法：冲突后为该散列值添加一条链保持数据（Java HashMap）。 换Hash函数：建立Hash函数链，一个冲突后使用下一个。 建立溢出区：冲突后的元素一律进入公共溢出区。 7.3 平衡树 二叉查找树 规定二叉树的左子树根 ，则该树的中序序列即为有序序列，查找时间O(logN)； 当结点被删除时： 只有一个子树，子树根替换当前结点。 有左右子树，找到左子树的最右结点替换当前结点（或右子树的最左结点）。 #include using namespace std; struct Node { int val; Node *L, *R; Node() { val = 0; L = R = nullptr; } }; void build(Node *&p, int e); void dfsMid(Node *p); int main() { int arr[] = {3, 5, 7, 2, 0, 9, 4, 11, 13, 1}; Node *root = nullptr; for (int i : arr) { if (root == nullptr) { root = new Node; root->val = i; } else { // 构建二叉查找树 build(root, i); } } // 中序遍历得到排序序列 dfsMid(root); return 0; } void build(Node *&p, int e) { if (p == nullptr) { p = new Node; p->val = e; } else if (e val) { build(p->L, e); } else { build(p->R, e); } } void dfsMid(Node *p) { if (nullptr == p) { return; } dfsMid(p->L); cout val R); } 为控制数的深度，应旋转使左右子树深度相差不大，否则查找的时间复杂度会退化到O(N)。 自平衡树(AVL) AVL是一棵有限制的二叉搜索树(L )，其要求左右子树深度最大不超过1(|depth(L) - depth(R)| )。 最小不平衡树：|depth(L) - depth(R)| == 2的子树，当结点插入AVL时最多有1棵最小不平衡树。 旋转 LL型右旋：当新结点在最小不平衡树的左孩子的左子树中时；将左子结点旋转到根。 RR型左转：当新结点在最小不平衡树的右孩子的右子树中时；将右子结点旋转到根。 LR型旋转：当新结点在最小不平衡树的左孩子的右子树中时；先将左子结点的右子结点旋转到左子树根，再将左子结点旋转到根。 RL型旋转：当新结点在最小不平衡树的右孩子的左子树中时；先将右子结点的左子结点旋转到右子树根，再将右子结点旋转到根。 删除 叶子结点：直接删除，再向上调整平衡 非叶子结点： 只有左孩子：用前驱结点的值替换当前结点，再移除前驱结点。 只有右孩子：用后继结点的值替换当前结点，再移除后继结点。 有左右孩子：用层级更高的子树中的前驱/后继结点的值替换当前结点，再移除子树中的结点。 #include using namespace std; struct Node { int val; int d; Node *L, *R; Node(int v) { val = v; d = 1; L = R = nullptr; } inline int getLDepth() { return getDepth(L); } inline int getRDepth() { return getDepth(R); } inline static int getDepth(Node *p) { return nullptr == p ? 0 : p->d; } }; void l2Root(Node *&root) { // 将root->L旋转到root的位置 Node *p = root->L; root->L = p->R; p->R = root; p->R->d = max(p->R->getLDepth(), p->R->getRDepth()) + 1; p->d = max(p->getLDepth(), p->getRDepth()) + 1; root = p; // root=l2Root(root) } void r2Root(Node *&root) { // 将root->R旋转到root的位置 Node *p = root->R; root->R = p->L; p->L = root; p->L->d = max(p->L->getLDepth(), p->L->getRDepth()) + 1; p->d = max(p->getLDepth(), p->getRDepth()) + 1; root = p; // root=r2Root(root) } void reBalance(Node *&p) { // 刷新根p的子树高度，并对p子树做平衡处理 if (nullptr == p) return; p->d = max(p->getLDepth(), p->getRDepth()) + 1; // 刷新当前子树高度 if (p->getLDepth() - p->getRDepth() > 1) { int lLDepth = Node::getDepth(p->L->L); int lRDepth = Node::getDepth(p->L->R); if (lLDepth >= lRDepth) { // LL型 l2Root(p); } else { // LR型 r2Root(p->R); l2Root(p); } } else if (p->getRDepth() - p->getLDepth() > 1) { int rLDepth = Node::getDepth(p->R->L); int rRDepth = Node::getDepth(p->R->R); if (rRDepth >= rLDepth) { // RR型 r2Root(p); } else { // RL型 l2Root(p->L); r2Root(p); } } } void add(Node *&p, int n) { if (nullptr == p) { p = new Node(n); return; } if (n val) add(p->L, n); else add(p->R, n); reBalance(p); } void remove(Node *&p, int n) { if (nullptr == p) return; if (n val) remove(p->L, n); else if (n > p->val) remove(p->R, n); else if (p->val == n) { if (nullptr == p->L && nullptr == p->R) { // 只有叶子结点可以直接删除 p = nullptr; return; } if (p->getLDepth() >= p->getRDepth()) { // 左子树高度更高，找前驱结点做根 Node *tmp = p->L; while (nullptr != tmp->R) tmp = tmp->R; p->val = tmp->val; remove(p->L, tmp->val); } else { // 右子树高度更高，找后继结点做根 Node *tmp = p->R; while (nullptr != tmp->L) tmp = tmp->L; p->val = tmp->val; remove(p->R, tmp->val); } } reBalance(p); // 平衡处理 } Node *find(Node *const p, int n) { if (nullptr == p) return nullptr; if (p->val == n) return p; Node *res; if (n > p->val && nullptr != (res = find(p->R, n))) return res; return find(p->L, n); } // ================================================================== void dfs(Node *p, const string &s, const string &pre) { if (nullptr == p) return; cout val L, s + \"| \", \"|--\"); dfs(p->R, s + \"| \", \"|++\"); } int main() { Node *root = nullptr; for (int i = 1; i 7.4 B树 TODO【待补充】 7.5 红黑树 TODO【待补充】 "},"chapter8/8.排序.html":{"url":"chapter8/8.排序.html","title":"8. 排序","keywords":"","body":"8. 排序 排序算法 类别 方法 时间 空间复杂度 稳定 平均 最坏 辅助空间 插入类 直接插入 O(N^2) O(N^2) O(1) Y 希尔排序 O(N^1.3) O(N^2) O(1) N 选择类 直接选择 O(N^2) O(N^2) O(1) N 堆排序 O(NlogN) O(NlogN) O(1) N 交换类 冒泡排序 O(N^2) O(N^2) O(1) Y 快速排序 O(NlogN) O(N^2) O(logN) N 分治 归并排序 O(NlogN) O(NlogN) O(N) Y 统计 进制位 O(d*(r+N)) O(d*(r+N)) O(r*d+N) Y 计数排序 O(N) O(N) O(N) N 注： N指元素(排序关键字)数量；logN表示 Log2N 基数排序中，r表示关键字的基数(进制)，d表示长度(位数）。 8.1 插入类排序 直接插入排序 逆向遍历数据，直到找到在有序序列中在待插入元素前的元素位置pos； 把待插入元素放在(pos+1)的位置。 // 插入类：直接插入排序 void insertSort(const int *arr, int len) { int *sorted = new int[len]; int sortedLen = 0, pos, key; for (int i = 0; i = 0; pos--) { if (key >= sorted[pos]) { // 一旦找到大于或等于待插入元素的数据，就把元素插入在本元素后（稳定性）。 break; } // 当前不是则后移 sorted[pos + 1] = sorted[pos]; } sorted[pos + 1] = key; sortedLen++; } print(sorted, sortedLen); } 希尔排序 通过一个增量delta把数组成delta组（类似报相同数的队员出列成组）。 同组的元素通过插入排序排好序。 缩小增量直到delta=1，此时即可得到有序序列。 注：由于存在不相邻元素的交换，所以无法保证稳定性。 // 插入类：希尔排序 void shellSort(int *arr, int left, int right) { int temp; // 二分缩小delta，整数倍增量的数据分为一组。 for (int delta = right - left; 0 != delta; delta /= 2) { // 遍历所有分组 for (int i = 0; i = left; j -= delta) { if (arr[j] >= arr[j - delta]) { break; } // 交换 j , j-delta temp = arr[j]; arr[j] = arr[j - delta]; arr[j - delta] = temp; } } } } print(arr, right); } 8.2 选择类排序 直接选择排序 每次选择一个第i优先的数据放在i位置。 直到所有数据被选择完毕。 注： 需要n-1次选择，每次选择需要n-i次比较（累计(n-1)*(n-1+1) / 2次），每次选择最多3次移位。（所以数据占字节多的时候性能优于直接插入排序）； 存在不相邻元素的交换所以不保证稳定性； // 选择类：直接选择排序 void selectSort(int *arr, int len) { int temp; // 选择一个第i小的数放在i位置 for (int i = 0; i 堆排序 初建堆：逆向从第一个非叶子(N/2)结点到根，依次调整树。 取堆顶：取出堆顶后，根位置放堆尾元素然后调整堆。 注：堆排序能在仅使用O(1)辅助空间的情况下保证速度O(NlogN)，但由于存在非相邻元素交换，不能保证稳定性。 // 选择类：堆排序-堆调整 void heapSortAdjust(int *arr, int start, int last) { // 记录根结点（小根堆） int root = arr[start]; for (int j = 2 * start; j arr[j + 1]) { j++; } if (root 0; i--) { heapSortAdjust(arr, i, last); } // 取堆顶元素 for (int i = last; i > 0; i--) { arr[0] = arr[1]; arr[1] = arr[i]; arr[i] = arr[0]; heapSortAdjust(arr, 1, i - 1); } print(arr + 1, last); } 8.3 交换类排序 冒泡排序 每次冒泡确定一个元素的位置（序列尾部）。 累计冒泡N-1次 注：由于仅存在相邻元素的交换，冒泡排序是稳定的。 // 交换类：冒泡排序 void bubbleSort(int *arr, int len) { int temp; // 冒泡N-1次，每次能确定一个元素的位置 for (int i = 0; i 快速排序 随机选定一个元素作为分界点值。 比界值优先级低的元素放到右边，比界值优先级高的元素放到左边。 把界值放到预期位置。 递归处理子区间。 注： 如果划分后有子表为空，则为最差情况（时间O(N^2),空间O(N)）。 由于需要递归栈（树深度为[logN+1, N]）所以平均辅助空间为logN。 快速排序在数据规模变大的时候，性能优势会更加明显(比之堆排，指令数更少，CPU缓存命中率更高)。 // 交换类：快速排序 void quickSort(int *arr, int left, int right) { if (left + 1 >= right) { return; } int split = arr[left], i = left, j = right - 1; // 寻找split的目标位置，比split优先的元素放在左边，否则放在右边 while (i = split) { j--; } // 放左边 arr[i] = arr[j]; // 找到split左边比界值更落后的元素aar[i] while (i 8.4 统计类排序 进制位排序 按数据的位值分桶统计。 再按统计把数据放到正确的位置。 遍历数据的所有位（位数多：从高到底；位数少：从低到高）后得到有序序列。 注： LSD最低位优先：先从kd开始排序，再对kd-1进行排序，依次重复直到对k1排序后便得到一个有序序列。 MSD最高位优先：先按k1排序分组，同一组中的数据关键码k1相等；再对各组按k2排序分成子组，直到按最次位关键码kd对各子组排序后。再将各组连接起来便得到一个有序序列。 // 统计：基数排序 void radixSort(int arr[], int len) { int *tmp = new int[len]; int *cnt = new int[10]; int radix = 1; // 初始分桶从低位开始 int d; // 位数，最大数据值长度 // 求数组最大值的位数 int maxNum = *max_element(arr, arr + len); for (d = 1; maxNum > 0; maxNum /= 10) { d++; } // 进行d次排序 for (int i = 0; i = 0; j--) { k = (arr[j] / radix) % 10; // cnt[k] - 1 即为 arr[j] 的预期位置 tmp[cnt[k] - 1] = arr[j]; cnt[k]--; } // 将临时数组的内容复制到数据集中 memcpy(arr, tmp, len * sizeof(int)); // 切换到高位 radix *= 10; } delete[] tmp; delete[] cnt; print(arr, 10); } 计数排序 如果数据值不大而数据量很大，可以考虑按值统计数量，然后按顺序输出，比如：年龄排序问题。 #include using namespace std; int main() { int bucket[101]; int N, age; cin >> N; while (N--) { cin >> age; // 直接统计年龄 bucket[age]++; } // 按序输出统计数量 for (int i = 0; i 8.5 归并排序 把序列分成两个子序列，递归下去直到子序列长度为1。 按顺序合并序列到一起。 注：当数据规模扩大的时候，快排 > 归并 > 希尔 > 堆 // 分治：归并排序 void mergeSort(int *arr, int left, int right) { if (left + 1 >= right) { return; } // 找到二分点 int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid, right); int i = left, j = mid; int *temp = new int[right - left], ap = 0; // 合并两个部分 while (i "},"chapter9/9.二进制.html":{"url":"chapter9/9.二进制.html","title":"9. 二进制","keywords":"","body":"9. 二进制 9.1 二进制编码和运算符 编码与存储 类型 含义 目的 示例(-3) 原码 最高位为符号位，0表正数，1表负数 解决正负问题 1011 反码 除符号位外，全部位取反 解决正负相加问题 1100 补码 即补数，在反码基础上补加一个1 减法转成加法，方便电路实现 1101 注： 有模的计量系统中，减去一个数，相当于加上这个数的补数；补码就是原码的补数。 比如,从9点拨动时针到11点，可以正向拨2格(+2)，也可以反向拨10格(-10)，因为表盘中模为12。 补数的补数是原数，即：奇数次 取反加一 得到相反数，偶数次 取反加一 会回到原数。 补码中不再有正负0，原码中的负01000反码为1111，但1000在补码中表示-8（四位中最小的负数，最高位既是符号位也是溢出位）；1111在补码中表示-1。 位运算符 位运算基于补码，直接操作内存；只能操作整型数据，无法对浮点数据做位运算。 取反~：全部位取反； ~(~N) = N: 偶数次取反得到原值。 与&：只有1&1=1； 对2的整数幂取余数N % 2^n 等价于 N & (2^n - 1) 若N为正整数，有N & (N-1) ==0 或 N & (-N) = N时，N为2的整数幂 或|：只有0|0=0； 异或^：相同为0，相异为1；异或是不进位的加法。 数与0的异或结果为自身：N ^ 0 = N 数与自身的异或结果为0：N ^ N = 0 偶数次异或相当于没异或 数与-1的异或相当于取反：N ^ -1 = ~N 左移：低位补0； 左移N位相当于乘2^N：N N *= 2 右移>>：无符号数高位补0，有符号数右移有两种实现： 算术右移：高位补符号位，正数最终变为0，负数最终变为-1(11111)。 逻辑右移>>>：不论正负数高位都补0。 存储 容量：8bit = 1Byte Int：4Byte（数据范围 [-2^31, 2^31-1]） Float：4Byte，有效小数精度6~7位（1位符号，8位指数，23位尾数:2^23=8388608）。 Double：8Byte，有效小数精度15~16位（1位符号，11位指数，52位尾数:2^52=4503599627370496）。 数据在内存中以二进制保存，其中： 常量数0x前缀表16进制，如0x7f7f7f7f；前缀0表八进制，如0777 常量数值后缀U区分有无符号位，后缀L区分是否长整型 常量数值的指数表达：3.14159 = 314159E-5L 进制转换： 十进制转R进制：整数部分除R逆取余，小数部分乘R顺取整 十六进制的一个位相当于二进制的4个位，八进制一位相当于二进制3个位。 9.2 掩码与状态 位运算 优势：减小对象创建销毁的消耗、内存占用 以及 运算速度更快。 劣势：表达复杂数据时，可读性和易使用性较差。 class Choice { public: static const int C_MUSIC = 0x1 9.3 二的整数幂 奇偶性 一个数对二的整数幂求模，相当于和其减一值做与运算x % (2^n) == x & (2^n - 1)。 if (x & 1) { // odd } else { // even } 二的整数幂 判断给出的数是否是2的整数幂。 bool isPowerOfTwo(int x) { // 2^n & 2^n - 1 == 0 return x > 0 && !(x & (x - 1)); } 9.4 正负和绝对值 判断正负 int isPositive(int a) { // 存在非0位，且符号为为0 return (a & 0xFFFFFFFF) && !(a & 0x80000000); } int isZero(int a) { // 所有位都是0 return !(a & 0xFFFFFFFF); } int isNegative(int a) { // 符号位为1 return a & 0x80000000; } 求绝对值 int abs(int x) { int i = x >> 31; // 算术右移，取符号位 return (x ^ i) - i; // return i==0 ? n : (~n + 1); } 9.5 两数交换 void i_swap(int &a, int &b) { if (a == b) { return; } a ^= b; // a = a + b; b ^= a; // b = a - b; a ^= b; // a = a - b; } 9.6 比较大小 int biggerPos(int a, int b) { int c = 1; b = (a ^ b); if (isZero(b)) return -1; // equals while (b >>= 1) { c b return positive integer(2^x); int bigger(int a, int b) { if (isNegative(a)) { if (isNegative(b)) { return biggerPos(complement(b), complement(a)); } return 0; // -a -b return biggerPos(a, b); } 9.7 位运算实现四则运算 // f(x) = a + b // 无进位加法+进位数 int _add(int a, int b) { int ans; // b非0表示需要运算|进位 while (b) { ans = a ^ b; // 先保存没进位的加法结果 b = ((a & b) > 1); } return ans; } // f(x) = a * b int _mul(int a, int b) { // 非零数乘以0等于0 if (isZero(a) || isZero(b)) { return 0; } // 正数直接相乘 if (isPositive(a) && isPositive(b)) { return mulPos(a, b); } if (isNegative(a)) { if (isNegative(b)) { // 负负得正 return mulPos(complement(a), complement(b)); } // 负号提取出来 return complement(mulPos(complement(a), b)); } return complement(mulPos(a, complement(b))); } // 贪心：如果a够减,依次减掉b*(2^31),b*(2^30),...b*(2^0)；减掉b*(2^i)就在结果加上2^i。 int divPos(int a, int b) { int ans = 0; for (int i = 31; i >= 0; i--) { // a>=b*(2^i)？以下写法避免b*(2^i)溢出 if ((a >> i) >= b) { a = _sub(a, b 9.8 二进制应用 出现奇数次的数 一组数中，除了N只出现过1次，其他数都出现过2次，请找出N。 int findN(int* arr, int len) { int ans = 0; for (int i = 0; i 不使用算术运算求N/3 给出正整数N，要求不使用+ - * /运算符，求出N/3。 // 任意正整数 n = 4 * (n/4) + (n%4) = 4a+b; 故有 n/3 = a + (a+b)/3 int divBy3(int n) { int res = 0; while (n > 3) { res = _add(n >> 2, res); // res += a; n = _add(n >> 2, n & 3); // n = a+b; } if (n == 3) res = _add(res, 1); return res; } 统计二进制中1的个数 // 左移1去对比每个位 // O(N),N为bit数 int countBit0(int x) { int ans = 0; int flag = 1; while (flag) { if (x & flag) { ans++; } flag > 1) & 0x55555555); x = (x & 0x33333333) + ((x >> 2) & 0x33333333); x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f); x = (x & 0x00ff00ff) + ((x >> 8) & 0x00ff00ff); x = (x & 0x0000ffff) + ((x >> 16) & 0x0000ffff); // 分区统计 return x; } "}}