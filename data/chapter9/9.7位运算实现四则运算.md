# 9.7 位运算实现四则运算

```cpp
// f(x) = a + b
// 无进位加法+进位数
int _add(int a, int b) {
    int ans;
    // b非0表示需要运算|进位
    while (b) {
        ans = a ^ b;        // 先保存没进位的加法结果
        b = ((a & b) << 1); // 取出需要进位的数,再加进去
        a = ans;
    }
    return ans;
}

// f(x) = -a
// 取补数,即取相反数
int complement(int a) { return _add(~a, 1); }

// 减法：有模的计数系统，减去数等价于加它的补数(溢出后得到减法结果)。
int _sub(int a, int b) {
    return _add(a, complement(b));
}

// 无符号乘法
// 依次加上左移后的加数（b个a相加）
int mulPos(int a, int b) {
    int ans = 0;
    while (b) {
        if (b & 1) {
            ans = _add(ans, a); // ans += a;
        }
        a = (a << 1);
        b = (b >> 1);
    }
    return ans;
}

// f(x) = a * b
int _mul(int a, int b) {
    // 非零数乘以0等于0
    if (isZero(a) || isZero(b)) {
        return 0;
    }
    // 正数直接相乘
    if (isPositive(a) && isPositive(b)) {
        return mulPos(a, b);
    }
    if (isNegative(a)) {
        if (isNegative(b)) {
            // 负负得正
            return mulPos(complement(a), complement(b));
        }
        // 负号提取出来
        return complement(mulPos(complement(a), b));
    }
    return complement(mulPos(a, complement(b)));
}

// 贪心：如果a够减,依次减掉b*(2^31),b*(2^30),...b*(2^0)；减掉b*(2^i)就在结果加上2^i。
int divPos(int a, int b) {
    int ans = 0;
    for (int i = 31; i >= 0; i--) {
        // a>=b*(2^i)？以下写法避免b*(2^i)溢出
        if ((a >> i) >= b) {
            a = _sub(a, b << i); // a -= (b << i);
            ans = _add(ans, 1 << i); // ans += (1 << i);
        }
    }
    return ans;
}

// f(x) = a / b
int _div(int a, int b) {
    // 除数不能为0
    if (isZero(b)) {
        throw invalid_argument("Divisor is Zero!");
    }
    // 被除数为0，则商为0
    if (isZero(a)) {
        return 0;
    }
    // 正数直接相除
    if (isPositive(a) && isPositive(b)) {
        return divPos(a, b);
    }
    // 存在一个负数提取负号
    if (isPositive(b)) {
        return complement(divPos(complement(a), b));
    } else if (isPositive(a)) {
        return complement(divPos(a, complement(b)));
    }
    // 负负得正
    return divPos(complement(a), complement(b));
}
```

