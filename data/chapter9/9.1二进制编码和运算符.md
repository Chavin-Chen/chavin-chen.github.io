# 9.1 二进制编码和运算符

## 编码与存储
|类型|含义|目的|示例(-3)|
|:-|:-|:-|:-|
|原码|最高位为符号位，0表正数，1表负数|解决正负问题|1011|
|反码|除符号位外，全部位取反|解决正负相加问题|1100|
|补码|即补数，在反码基础上补加一个1|减法转成加法，方便电路实现|1101|

**注**：
1. 有模的计量系统中，减去一个数，相当于加上这个数的补数；补码就是原码的补数。
比如,从9点拨动时针到11点，可以正向拨2格(+2)，也可以反向拨10格(-10)，因为表盘中模为12。
2. 补数的补数是原数，即：奇数次 *取反加一* 得到相反数，偶数次 *取反加一* 会回到原数。
3. 补码中不再有正负0，原码中的负0`1000`反码为`1111`，但`1000`在补码中表示-8（四位中最小的负数，最高位既是符号位也是溢出位）；`1111`在补码中表示-1。

## 位运算符
位运算基于**补码**，直接操作内存；只能操作**整型数据**，无法对浮点数据做位运算。

1. 取反`~`：全部位取反；
    - `~(~N) = N`: 偶数次取反得到原值。
2. 与`&`：只有`1&1=1`；
    - 对2的整数幂取余数`N % 2^n` 等价于 `N & (2^n - 1)`
    - 若N为正整数，有`N & (N-1) ==0` 或 `N & (-N) = N`时，N为2的整数幂
3. 或`|`：只有`0|0=0`；
4. 异或`^`：相同为0，相异为1；异或是不进位的加法。
    - 数与0的异或结果为自身：`N ^ 0 = N`
    - 数与自身的异或结果为0：`N ^ N = 0` 偶数次异或相当于没异或
    - 数与-1的异或相当于取反：`N ^ -1 = ~N`
5. 左移`<<`：低位补0；
    - 左移N位相当于乘2^N：`N <<= 1` <=> `N *= 2`
6. 右移`>>`：无符号数高位补0，有符号数右移有两种实现：
    - 算术右移：高位补符号位，正数最终变为0，负数最终变为-1(`11111`)。
    - 逻辑右移`>>>`：不论正负数高位都补0。

## 存储
1. 容量：8bit = 1Byte
	- `Int`：4Byte（数据范围 [-2^31, 2^31-1]）
	- `Float`：4Byte，有效小数精度`6~7`位（1位符号，8位指数，23位尾数:2^23=8388608）。
	- `Double`：8Byte，有效小数精度`15~16`位（1位符号，11位指数，52位尾数:2^52=4503599627370496）。
2. 数据在内存中以二进制保存，其中：
	- 常量数`0x`前缀表16进制，如`0x7f7f7f7f`；前缀0表八进制，如`0777`
	- 常量数值后缀`U`区分有无符号位，后缀`L`区分是否长整型
	- 常量数值的指数表达：`3.14159 = 314159E-5L`
3. 进制转换：
	- 十进制转R进制：整数部分除R逆取余，小数部分乘R顺取整
	- 十六进制的一个位相当于二进制的4个位，八进制一位相当于二进制3个位。
