# 8.3 交换类排序

## 冒泡排序
1. 每次冒泡确定一个元素的位置（序列尾部）。
2. 累计冒泡N-1次

*注：*由于仅存在相邻元素的交换，冒泡排序是稳定的。

```cpp
// 交换类：冒泡排序
void bubbleSort(int *arr, int len) {
    int temp;
    // 冒泡N-1次，每次能确定一个元素的位置
    for (int i = 0; i < len - 1; i++) {
        // 冒泡确定 arr[len-i] 位置的元素
        for (int j = 0; j < len - i - 1; j++) {
            if (arr[j] <= arr[j + 1]) {
                continue;
            }
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }

    print(arr, len);
}

```


## 快速排序
1. 随机选定一个元素作为分界点值。
2. 比界值优先级低的元素放到右边，比界值优先级高的元素放到左边。
3. 把界值放到预期位置。
4. 递归处理子区间。

*注：*
- 如果划分后有子表为空，则为最差情况（时间`O(N^2)`,空间`O(N)`）。
- 由于需要递归栈（树深度为`[logN+1, N]`）所以平均辅助空间为`logN`。
- 快速排序在数据规模变大的时候，性能优势会更加明显(比之堆排，指令数更少，CPU缓存命中率更高)。

```cpp
// 交换类：快速排序
void quickSort(int *arr, int left, int right) {
    if (left + 1 >= right) {
        return;
    }
    int split = arr[left], i = left, j = right - 1;
    // 寻找split的目标位置，比split优先的元素放在左边，否则放在右边
    while (i < j) {
        // 找到split右边比界值更优先的元素arr[j]
        while (i < j && arr[j] >= split) {
            j--;
        }
        // 放左边
        arr[i] = arr[j];
        // 找到split左边比界值更落后的元素aar[i]
        while (i < j && arr[i] <= split) {
            i++;
        }
        // 放右边
        arr[j] = arr[i];
    }
    // 放界值
    arr[i] = split;
    // 递归子区间
    quickSort(arr, left, i);
    quickSort(arr, i + 1, right);
}
```