# 8.2 选择类排序


## 直接选择排序
1. 每次选择一个第i优先的数据放在i位置。
2. 直到所有数据被选择完毕。

*注：*
需要n-1次选择，每次选择需要n-i次比较（累计(n-1)*(n-1+1) / 2次），每次选择最多3次移位。（所以数据占字节多的时候性能优于直接插入排序）；
存在不相邻元素的交换所以不保证稳定性；


```cpp
// 选择类：直接选择排序
void selectSort(int *arr, int len) {
    int temp;
    // 选择一个第i小的数放在i位置
    for (int i = 0; i < len - 1; i++) {
        for (int j = i + 1; j < len; j++) {
            if (arr[j] < arr[i]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    print(arr, len);
}
```


## 堆排序
1. 初建堆：逆向从第一个非叶子(N/2)结点到根，依次调整树。
2. 取堆顶：取出堆顶后，根位置放堆尾元素然后调整堆。

*注：*堆排序能在仅使用O(1)辅助空间的情况下保证速度O(NlogN)，但由于存在非相邻元素交换，不能保证稳定性。

```cpp
// 选择类：堆排序-堆调整
void heapSortAdjust(int *arr, int start, int last) {
    // 记录根结点（小根堆）
    int root = arr[start];
    for (int j = 2 * start; j <= last; j *= 2) {
        // 找到子结点中更优先（小）的结点
        if (j < last && arr[j] > arr[j + 1]) {
            j++;
        }
        if (root <= arr[j]) {
            // 如果根结点比子结点更优先（小）：调整成功
            break;
        }
        // 更新根结点（子结点上浮）
        arr[start] = arr[j];
        // 切到子树
        start = j;
    }
    // 在合适的位置插入放置根结点
    arr[start] = root;
}

// 选择类：堆排序
void heapSort(int *arr, int last) {
    // 初建立堆 [1, last]
    for (int i = last / 2; i > 0; i--) {
        heapSortAdjust(arr, i, last);
    }
    // 取堆顶元素
    for (int i = last; i > 0; i--) {
        arr[0] = arr[1];
        arr[1] = arr[i];
        arr[i] = arr[0];
        heapSortAdjust(arr, 1, i - 1);
    }
    print(arr + 1, last);
}
```