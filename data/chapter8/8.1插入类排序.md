# 8.1 插入类排序

## 直接插入排序
1. 逆向遍历数据，直到找到在有序序列中在待插入元素前的元素位置`pos`；
2. 把待插入元素放在`(pos+1)`的位置。

```cpp
// 插入类：直接插入排序
void insertSort(const int *arr, int len) {
    int *sorted = new int[len];
    int sortedLen = 0, pos, key;
    for (int i = 0; i < len; i++) {
        key = arr[i];
        // 寻找在插入元素arr[i]前面的元素pos;
        for (pos = sortedLen - 1; pos >= 0; pos--) {
            if (key >= sorted[pos]) {
                // 一旦找到大于或等于待插入元素的数据，就把元素插入在本元素后（稳定性）。
                break;
            }
            // 当前不是则后移
            sorted[pos + 1] = sorted[pos];
        }
        sorted[pos + 1] = key;
        sortedLen++;
    }
    print(sorted, sortedLen);
}
```

## 希尔排序
1. 通过一个增量delta把数组成delta组（类似报相同数的队员出列成组）。
2. 同组的元素通过插入排序排好序。
3. 缩小增量直到delta=1，此时即可得到有序序列。

*注：*由于存在不相邻元素的交换，所以无法保证稳定性。

```cpp
// 插入类：希尔排序
void shellSort(int *arr, int left, int right) {
    int temp;
    // 二分缩小delta，整数倍增量的数据分为一组。
    for (int delta = right - left; 0 != delta; delta /= 2) {
        // 遍历所有分组
        for (int i = 0; i < delta; i++) {
            // 同分组的数据使用插入排序
            for (int k = (left + i) + delta; k < right; k += delta) {
                for (int j = k; j - delta >= left; j -= delta) {
                    if (arr[j] >= arr[j - delta]) {
                        break;
                    }
                    // 交换 j , j-delta
                    temp = arr[j];
                    arr[j] = arr[j - delta];
                    arr[j - delta] = temp;
                }
            }
        }
    }
    print(arr, right);
}
```
