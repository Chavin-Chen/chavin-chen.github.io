# 8.4 统计类排序

## 进制位排序
1. 按数据的位值分桶统计。
2. 再按统计把数据放到正确的位置。
3. 遍历数据的所有位（位数多：从高到底；位数少：从低到高）后得到有序序列。

*注：*
- LSD最低位优先：先从kd开始排序，再对kd-1进行排序，依次重复直到对k1排序后便得到一个有序序列。
- MSD最高位优先：先按k1排序分组，同一组中的数据关键码k1相等；再对各组按k2排序分成子组，直到按最次位关键码kd对各子组排序后。再将各组连接起来便得到一个有序序列。

```cpp
// 统计：基数排序
void radixSort(int arr[], int len) {
    int *tmp = new int[len];
    int *cnt = new int[10];
    int radix = 1;  // 初始分桶从低位开始
    int d;          // 位数，最大数据值长度

    // 求数组最大值的位数
    int maxNum = *max_element(arr, arr + len);
    for (d = 1; maxNum > 0; maxNum /= 10) {
        d++;
    }

    // 进行d次排序
    for (int i = 0; i < d; i++) {
        // 每次分配前清空计数器
        memset(cnt, 0, sizeof(int) * 10);

        // 统计每个桶中的数据量
        for (int j = 0; j < len; j++) {
            cnt[(arr[j] / radix) % 10]++;
        }
        // 从小到大累加，用于确定某个位值得预期位置
        for (int j = 1; j < 10; j++) {
            cnt[j] += cnt[j - 1];
        }

        // 将所有桶中记录依次收集到tmp中
        for (int j = len - 1, k; j >= 0; j--) {
            k = (arr[j] / radix) % 10;
            // cnt[k] - 1 即为 arr[j] 的预期位置
            tmp[cnt[k] - 1] = arr[j];
            cnt[k]--;
        }

        // 将临时数组的内容复制到数据集中
        memcpy(arr, tmp, len * sizeof(int));
        // 切换到高位
        radix *= 10;
    }
    delete[] tmp;
    delete[] cnt;
    print(arr, 10);
}
```


## 计数排序
如果数据值不大而数据量很大，可以考虑按值统计数量，然后按顺序输出，比如：年龄排序问题。

```cpp
#include <iostream>
using namespace std;

int main() {
    int bucket[101];
    int N, age;
    cin >> N;
    while (N--) {
        cin >> age;
        // 直接统计年龄
        bucket[age]++;
    }
    // 按序输出统计数量
    for (int i = 0; i < 100; i++) {
        while (0 != bucket[i]--) {
            cout << i << " ";
        }
    }
    cout << endl;
    return 0;
}
```