# 2.2 链表
链表是碎片化的小内存，不同碎片间维护了其他碎片的内存地址，只能顺序读取，但插入和删除元素时无需移动大量元素。

```cpp
struct Node {
    int val;
    Node *next;
} *p = new Node, *tmp;

int main() {
    // 在p结点后插入结点
    tmp = p->next;       // 保存next结点
    p->next = new Node;  // 插入新结点
    p->next->next = tmp; // 新结点链接上原后继结点链

    // 删除p结点的后继结点
    tmp = p->next;       // 保存next结点
    p->next = tmp->next; // 覆盖后继结点
    delete tmp;          // 释放内存
    return 0;
}
```


## 2.2.1 判断链表中是否存在环
Floyd环判定算法-快慢指针：定义指针`slower`、`faster`；`slower`每次走1步`faster`每次走2步，若存在`slower==faster`则存在环；（时间:O(n),空间:O(1)）

另外：若可以改变链表结构，可修改遍历过结点的`next`使其指向一个固定的地址，同样可在O(n)时间内判断是否存在环。


## 2.2.2 求链表中环的起点
当以上`slower==faster`情况出现后，把`slower`重置为链表起点，此时两指针每次都同样只走1步，再相遇的点即为环起点。


## 2.2.3 求链表中环的长度
当`slower`和`faster`首次相遇后，停住`faster`继续走`slower`并统计，再次相遇即可得环长度。


证明第二问中环起点的解法正确：
设链表`总长S = 非环长m + 环长n`；由于首次相遇时`slower`总长为S，`faster`为2S：
- 两式分别为：①`S = m + A * n + k`、②`2*S = m + B*n + k` 其中A、B为正整数；
- 两式相减得：③`S = (B-A)*n`，即S长为整数倍环长；

结合①③式得`(m+k)`为整数倍环长，代入①式得`m = S - A*n - k`，
也即`m = C*n - k = (C-1)*n + (n-k)`，显然有下次两指针相再遇位置即为环起点。

![链表中的环](../.asset/link-node.png)