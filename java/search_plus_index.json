{"./":{"url":"./","title":"1. 基础语法","keywords":"","body":"1. 基础语法 1.1 编译运行 配置JDK环境 # 安装OpenJDK brew install openjdk@11 # 配置.bash_profile，支持手动切换Java版本 JAVA_8_HOME='/usr/local/opt/openjdk@8' JAVA_11_HOME='/usr/local/opt/openjdk@11' JAVA_18_HOME='/usr/local/opt/openjdk@18' export JAVA_HOME=$JAVA_11_HOME export PATH=\"$PATH:$JAVA_HOME/bin\" export CPPFLAGS=\"-I$JAVA_HOME/include\" # Ubuntu中可使用命令切换 sudo update-alternatives --config java # 查看Java版本 java --version 构建与分析 用javac编译、jar打包解包、javap反编译。 # 批量编译 javac -s -d *.java # 生成jar包, -C 表示打包是忽略该路径前缀 jar -c -f target.jar [-e com.test.Main] -C ./java/main ./ # 解压jar包到当前目录，或使用 unzip target.jar -d ./sub/ 指定解压目录 jar -xf target.jar # 执行, 注意java -jar时，即使传入classpath也会被忽略 java -classpath com.test.Main [cmd args] java -jar main.jar [cmd args] # 反编译 -c查看反汇编代码，-s查看签名 javap -c Main.class javap -v -p Main.class # 若只有单个文件，可快速编译并执行 java Main.java 1.2 数据类型 Java的基本类型在Java方法栈中分配空间，非基本类型在堆中分配空间。 基本数据类型 0Byte: void 其装箱类Void不能new实例 1Byte: byte 2Byte: char、short 4Byte: int、float 8Byte: long、double 数组 Java的数组是一种特殊的类： 可通过Class对象判断是否数组类型: obj.getClass().isArray() 或 obj instanceof int[] Java的数组是型变的, 即Integer -|> Object且有Integer[] -|> Object[] 成员length保存了数组元素数，成员方法clone()支持数组元素浅克隆 // 推荐使用T[] arr; (而非T arr[]），即可将T[]看成是类型名 // 不会为元素创建对象，即arr[i]==null Object[] arr = new Object[10]; // 定义时用元素列表初始化时可省略长度值 arr.length==2 Object[] arr = new Object[]{new Object(), new Object()} 类实例初始化顺序 类加载阶段: 链接阶段: 给静态变量赋默认值0/false/''/null 初始化阶段: 在堆中创建Class对象，再执行由静态变量赋值、静态代码块合成的()方法 对象创建阶段: 在Heap中开辟空间，成员初始化为0值 顺序将成员显式赋值、构造代码块指令合并插入到各构造方法体中(super()后) 执行对应的构造方法 1.3 语句结构 Java除支持常规的分支结构if-else、switch-case、循环结构while、do-while、for(;;)外，还支持： 迭代器循环 对于Iterrable的实现类，支持for-each语法糖： // 相当于 while(it.hasNext()){ e = it.next(); } for (Integer e : obj){ } 自动释放资源 对于AutoCloseable的实现类T，支持try(T t = new T())语法糖： // 相当于在finally块中调用了a.close()方法 try (AutoCloseable a1 = new T(); AutoCloseable a2 = new T()){ }catch (Exception ignore) {} 1.4 异常捕获 Java用throws在方法体前声明受检异常, 用throw在方法体中抛出异常, 用try-catch-finally在调用处捕获异常。 注: 方法复写时, 同返回值可以返回父类声明的相容类型一样，子类也可以声明与抛出父类声明的异常的相容类型。 "},"chapter2/2.面向对象.html":{"url":"chapter2/2.面向对象.html","title":"2. 面向对象","keywords":"","body":"2. 面向对象 2.1 封装 把事物的共同属性/行为抽象出来，在在使用函数结构化功能的同时，把对象数据和函数绑定，即：隐藏数据细节，公开访问方法。 包 包在文件系统体现为文件夹，在代码里用来标识类以及隔离数据访问，如package sup.pkg;的字节码查找路径为classpath中的sup/pkg/*.class 访问修饰 public: 完全开放，支持跨包访问 protected: 支持同名包内和子类访问 无修饰(default): 支持同名包内访问 private: 仅在当前类中可以被访问 2.2 继承 在已有的特征上(父类的数据结构和方法规范)拓展新特征，Java只支持单继承，但可以实现多个接口。 class Child extends Base implements IA,IB{ // extends 只能继承一个父类 // implements 可实现多个接口 public Child(){ // super 和 this 是每个类的固有成员 } // 子类重写方法时，访问限制不能严于父类，返回值可以是协变类型 public Integer call(){ } public static void main(String[] args) { Child obj = new Child(); // 用 instanceof 判断对象的类型 if(obj instanceof Base){ ((Base) obj).doSth(); } } } 抽象类和接口区别 概念上: 接口只定义行为规约 类是对事物的抽象，包含了事物属性和行为 语法上: 接口不能保存状态，但支持多实现 抽象类可以有数据成员和非抽象方法，只支持单继承 设计上: 接口是辐射式设计，接口变更后实现者都需要变更 抽象类是模板式设计，抽象类变更子类可以不变更 应用上: 实现者和接口是has-a关系，耦合程度更低 继承者和抽象类is-a关系，耦合度高(可优先考虑用组合替代继承：如实现多接口组合、成员聚合依赖类型) 2.3 多态 多态是指：同一消息发送给不同对象可以得到不同的响应。 静态多态：重载，方法同名不同参 动态多态：复写，方法同名且同参 内部类 静态内部类：不持有外部类指针，不和具体外部类实例绑定 成员内部类：持有外部类实例的this指针 匿名内部类：必须继承或实现一个接口，并同时创建匿名对象 class Outer { static class Nested{ // 静态内部类除类名有前缀外Outer$Nested.class，其他和外部类无差别 } class Inner { // 非静态内部类不能有静态成员，且会持有外部类的this指针 } public void f() { final int x = 0; // 定义匿名内部类，必须继承一个类或实现一个接口，并同时创建一个匿名对象。 Inner in = this.new Inner() { // 匿名内部类，只能访问外部final修饰的局部变量，但可以访问外部类的成员变量 }; } } "},"chapter3/3.泛型.html":{"url":"chapter3/3.泛型.html","title":"3. 泛型","keywords":"","body":"3. 泛型 3.1 类型擦除 类型参数化，即允许以参数形式传入不同类型，而复用其他和具体类型无关的逻辑。最终类型参数在编译时会用第一个限定类型擦除(没有限定用Object)。 注: Java的泛型是不型变的，即对于Wrapper和Wrapper，不论类型A和B是否相容，Wrapper、Wrapper都不相容。 class Wrapper> implements Comparable> { T data; Wrapper() { } public int dataLength() { // 复用 CharSequence::Length return this.data.length(); } @Override public int compareTo(Wrapper o) { // 复用 Comparable::compareTo return this.data.compareTo(o.data); } } 泛型和Object对比 泛型在编译期会检查受检类型的相容性，对于不相容的类型会编译失败, 具有更好的安全性和可读性； Object在运行时才检查类型相容（如,A a = (A) obj;），不相容会抛出ClassCastException // 泛型类或接口 class Wrapper{ T data; } // 泛型方法 public void act(T arg){ } 泛型使用的限制 不能创建泛型数组: 不能new List[10]; 但可以new List[10] 、new List[10] 不能创建占位符类型实例、捕获未知类型异常: new T();、try{ }catch(T e); 不能声明静态泛型成员: static T var; 涉及类型的操作只支持原始类型 实例判断：list instanceof List 强制转换：List list = (List) arrayList; Class对象：list.getClass() == ArrayList.class 3.2 使用处型变 子类型通配List 用于支持协变(从集合读取) 超类型通配List 用于支持逆变(向集合写入) 无限通配符List 只能读出Object对象，只能写入null // PECS法则 // Producer-Extends：只读不写，即只从`List`取数据 // Consumer-Super：只写不读，即只向`List`写数据 // Collections public static void copy(List dest, List src) { int srcSize = src.size(); if (srcSize di = dest.listIterator(); // in T ListIterator si = src.listIterator(); // out T for (int i = 0; i "},"chapter4/4.反射.html":{"url":"chapter4/4.反射.html","title":"4. 反射","keywords":"","body":"4. 反射 反射可在取得Class对象后，在不显示依赖具体类的情况下进行实例创建、方法调用、字段读写。 // (1)通过加载获取Class实例，Class对象是访问方法区该类型的唯一入口 Class clz = Class.forName(\"com.xxx.Xxx\"); // (2)在有依赖，或有该类型实例的情况下 clz = ClassName.class; clz = obj.getClass(); // 通过Constructor创建对象 Constructor construtor = clz.getDeclaredConstructor(char[].class); construtor.setAccessible(true); // 先构造非静态方法的绑定对象 Object obj = construtor.newInstance(new Object[]{new char[]{'a', 'b'}}); // getMethod会在当前类以及父类、父接口查找public成员 Method method = clz.getMethod(\"toUpperCase\", (Class[]) null); String upper = (String) method.invoke(obj, (Object[]) null); // getDeclaredField不会去父类查找，但也会查找类中非public的成员 Field field = clz.getDeclaredField(\"value\"); field.setAccessible(true); // 非public方法，先破坏封装 byte[] value = (byte[]) field.get(obj); field.set(obj, new byte[]{}); Java类型签名 用javap查看类结构签名javap -s ClassName: 基本数据类型：首字母大写, 2个例外: long->J(L被非基本类型占用), boolean->Z(B被Byte占用) 复合类型：L包名.类名;，注意分号是类签名的一部分如Ljava.lang.String; 数组签名[元素类型签名，如int[][] => [[I 方法签名(参数类型签名)返回值类型签名，如：String f(byte[][] a, boolean b); => ([[BZ)Ljava/lang/String; "},"chapter5/5.多线程.html":{"url":"chapter5/5.多线程.html","title":"5. 多线程","keywords":"","body":"5. 多线程 进程是OS进行资源分配和调度的单位，线程是CPU调度和分派的单位； 线程从属于进程且和进程中其他线程共享进程资源，线程上下文切换比进程更快； 跨进程通信需要IPC通道，多线程间通过共享内存高效通信(进程内存、打开的文件描述符、进程当前目录、用户ID和进程组ID,在线程间是共享的)。 5.1 线程和池 JVM进程启动后，会启动一个MAIN线程和GC守护线程。 线程状态 创建New: 尚未执行start()方法 就绪Runnable: 等待OS调度运行 阻塞Blocked: 等待获取到资源 等待Waiting: 主动放弃CPU(休眠,礼让,等待条件)等待被唤醒 thread#join(); 放弃锁进入Waiting,直到thread跑完才进入Runnable lock#wait(); 放弃锁进入Waiting,直到获取到lock的条件才进入Runnable Thread::sleep(); 保持锁进入Waiting,超时后转Runnable等调度 Thread::yield(); 保持锁进入Runnable,等待调度(只礼让高优先级) 终止Terminated: 线程自然终止或异常死亡 线程中断 thread.interrupt();: 将中断标记true(若正在sleep()/wait()等中断方法时,用异常打断) thread.isInterrupted();: 返回中断标记,无副作用; Thread::interrupted();: 返回中断标记,并把中断标记复位为false; Runnable runTask = new Runnable(){ public void run(){ // 检查中断标记 while(!Thread.currentThread().isInterrupted()){ try { Thread.sleep(2000); } catch (InterruptedException e) { // 外部调interrupt()抛异常中断本线程,中断标记需手动置为true Thread.currentThread().interrupt(); } } } } 线程访问变量 可见性：A线程的缓存对B线程不可见。 原子性：JVM只保证基本数据类型的读取和赋值是原子操作。 有序性：指令重排(.class/汇编/CPU指令)遵循happens-before规则，同as-if-serial语义，即线程的执行结果和排序前一致，即有数据依赖关系的指令不会被重排。 // final 保证final的变量在读取前其赋值操作已经完成。 // volatile 确保volatile写操作前后有屏障，并刷新主存、标记各线程缓存失效。 // synchronized 确保在获取和释放锁的时候都有内存屏障，且刷新主存并标记缓存失效。 // 原子类型 基于`UnSafe`类直接操作内存，禁止该指令与前后的指令重排序，并刷新主存并标记缓存失效。 // ThreadLocal变量在线程中是独立的，不同线程互不干扰; ThreadLocal format = ThreadLocal .withInitial(()->new SimpleDateFormat(\"yyyy-MM-dd\")); // 第一次使用会初始化并保存在ThreadLocalMap中, 之后使用本线程不再初始化直到线程被销毁 format.get(); 注: Key是虚引用ThreadLocal,该对象销毁后JVM会在get()/set()/remove()时清理Key.get()==null的Entry(即使这样仍然可能内存泄露); 线程优先级 优先级：Thread#setPriority(Thread.NORMAL_PRIORITY) 此优先级在Linux下无效 在start()前设置[10,1],值越大优先级越高; 默认父线程优先级,见Thread#init(); Thread.yield()只会礼让优先级相同或更高的线程; 守护线程：Thread#isDaemon();Thread#setDaemon(boolean)： 后台通用服务,并非不可或缺(例如:GC) 若进程只剩守护线程会被杀死,所以守护线程中读写文件容易损坏数据。 线程池 通过对象池复用方案来解决：频繁地线程创建、销毁带来的不必要损耗；控制对象数量以抑制内存上涨。 ThreadPoolExecutor( // 核心线程数,核心线程一直存活(即使空闲,除非allowCoreThreadTimeout(true)) corePoolSize, // 最大线程数 maximumPoolSize, // 非核心线程闲置时长,超时线程会被回收 keepAliveTime, // 时间单位,可用TimeUnit.MILLISECONDS timeUnit, // 任务队列,BlockingQueue workQueue, // 线程创建工厂 threadFactory, // 任务拒绝处理器, 默认ThreadPoolExecutor.AbortPolicy抛异常; rejectedExecutionHandler); 内置的线程池 FixedThreadPool：适用请求频繁,数量基本固定的任务(固定核心线程数无超时关闭，无非核心线程，无限任务队列持续等待) CachedThreadPool：适用数量庞大,耗时较少的任务(无核心线程，无限非核心线程(MAX_INT)超时60s关闭，空任务队列立即执行) SingleThreadPool：单线程模型用于避免并发时数据不同步问题(单核心线程，无非核心线程，无限任务队列持续等待) ScheduledThreadPool：适用于定时或周期性任务(核心线程数固定无超时关闭，无限非核心线程(MAX_INT)空闲即回收，空任务队列立即执行) Timer：基于系统绝对时间，单线程实现，某个任务执行(时长，异常)会影响其他任务调度。 ScheduledThreadPoolExecutor：基于相对时间，多线程实现，某个任务执行(时长，异常)不影响其他任务。 ScheduledExecutorService service = new ScheduledThreadPoolExecutor(5); // 周期执行,下次执行时间 = 本次任务开始时间 + 周期长 service.scheduleAtFixedRate(exeRun,0,1000,TimeUnit.MILLISECONDS); // 周期执行,下次执行时间 = 本次任务结束时间 + 周期长 service.scheduleWithFixedDelay(exeRun,0,1000, TimeUnit.MILLISECONDS); 5.2 锁和AQS synchronized锁住的是对象(对象头中包含锁状态), 只有一个竞争条件(wait()/notify()方法依赖JVM中Native层管程Monitor对象)。 可重入：内层方法默认具有外层方法的获得的锁(锁设计为按线程区分而非方法)。 非公平：OS为保证吞吐量，获得锁的顺序不一定同申请顺序(对象锁是非公平锁，AQS则可指定公平)。 读写锁：读读共享，读写互斥。 分段锁：ConcurrentHashMap在JDK7-对每个段加锁(DK8+对每个Entry加锁)以减少冲突提高吞吐。 AbstractQueuedSynchronizer ReentrantLock基于AQS实现独占锁，可构建公平或非公平锁。 CountDownLatch基于AQS逆用共享锁机制，实现异步闩。 /** ReentrantLock **/ ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); // 用tryLock()代替lock.lock()发生死锁时可超时终止 // lock.lockInterruptibly()无休止尝试直到被interrupt(); if (lock.tryLock(3000, TimeUnit.MILLISECONDS)) { try { if (不满足业务条件) { condition.await(); // 等待被唤醒: condition.signalAll(); } // 获取锁成功, do ... } finally { lock.unlock(); } } else { // // 获取锁超时, do ... } /** CountDownLatch **/ // 初始化,指定开闩任务数 CountDownLatch latch = new CountDownLatch(4); // 指派子任务完毕,关闩; 线程阻塞于此 latch.await(); // 子任务执行完毕,通知开闩 latch.countDown(); 5.3 J.U.C库 由于同步锁性能消耗大，而volatile只能保证可见性而无法保证原子性；现代CPU提供了硬件级指令实现同步原语(java.util.concurrent.*基于CAS性能更好)： // 如Intel: cmpxchg，以下假设当前内存值为V，预期值为A，待设置值为B // 其逻辑形如 while(true){ if (isOtherWriting) continue; // 检测到其他线程在写值，自旋(而非阻塞) if (V == A) { // CPU保证在 [V==A之后, 设置V=B前]不会有其他线程修改V值 isOtherWriting = true setV(B); isOtherWriting = false } // 预期值不符，设置失败 break; } 原子类AtomicXxx 通过CAS解决变量因多线程并发读写导致的数据异常 AtomicReference ref = new AtomicReference<>(\"A\"); ref.compareAndSet(\"A\", \"B\"); 竞争分量XxxAccumulator CAS在大量线程竞争时会不停自旋导致消耗过大，竞争分量通过分段的思想，将不同线程更新不同的段，最后再将各段合并进而提高效率。 // Adder: LongAdder, DoubleAdder // Accumulator: LongAccumulator, DoubleAccumulator // 初始化 LongAdder adder = new LongAdder(); // 子线程基于分量计算在单线程模型上保证原子性) adder.add(x); // adder.increment(); // 计算完毕后合并分量取结果 adder.sum(); 版本引用AtomicXxxReference CAS会存在ABA问题，通过为对象引用设置版本号来解决将先后两个A错误地认为是同一个对象问题。 // AtomicMarkableReference 使用Boolean值做\"版本号\" AtomicStampedReference ref = new AtomicStampedReference<>(\"A\", 0); ref.compareAndSet(\"A\", \"B\", ref.getStamp(), ref.getStamp() + 1); ref.compareAndSet(\"B\", \"A\", ref.getStamp(), ref.getStamp() + 1); 线程安全集合 用集合对象做锁集合: Collections.synchronizedCollection/synchronizedMap();、Vector、Statck、Hashtable、StringBuffer 性能更好的集合: CopyOnWriteArraySet/CopyOnWriteArrayList: 写入之前先拷贝一份出来给读使用 ConcurrentHashMap: 用更细粒度的锁减少冲突 J.U.C阻塞队列 阻塞队列在队列的基础上支持两个附加操作： 队列为空时，取元素的线程会等待，直到队列非空 队列已满时，加元素的线程会等待，直到队列可添加元素 /** 抛出异常 **/ boolean add(e); E remove(); E element(); /** 返回特殊值(非阻塞) **/ boolean offer(e); // 入队失败返回false; E poll(); // 出队失败返回null E peek(); // 检查失败返回null /** 超时退出(非持续阻塞) **/ boolean offer(e, time, unit); E poll(time, unit); /** 持续阻塞 **/ put(e); // 队满时等待条件 E take(); // 队空时等待条件 阻塞队列成员 ArrayBlockingQueue: 有界/数组; 默认非公平锁 LinkedBlockingQueue: 可选有界/链表; 读写分锁 PriorityBlockingQueue: 无界/堆; 优先级队列 DelayQueue: 无界/堆; 元素超时才可取出，可用于缓存系统、定时任务ScheduledThreadPool SynchronousQueue: 有界/无; 默认非公平锁, 每个put都须等一个take, 应用：CachedThreadPool LinkedBlockingDeque: 无界/链表; 支持双向读写(但锁是同一个) LinkedTransferQueue: 无界/链表; 在阻塞队列基础上多了transfer(e)/tryTransfer(e)方法 LinkedTransferQueue queue = new LinkedTransferQueue<>(); // 若有消费线程等待立即传递，否则元素插入队尾阻塞生产线程直到被取走 queue.transfer(\"\"); // 若有消费线程等待立即传递，否则返回false元素不进队列 queue.tryTransfer(\"\"); // 若有消费线程等待立即传递，否则元素进队尾阻塞若干时长，若期间被取走返回true否则超时时返回false queue.tryTransfer(\"\", 1000, TimeUnit.MILLISECONDS); FutureTask FutureTask可将Callable转换成Runnable交给线程执行，并可通过Future接口获取执行结果。 FutureTask task = new FutureTask<>(callable); new Thread(task).start(); result = task.get(); // 阻塞当前线程 "},"chapter6/6.IO操作.html":{"url":"chapter6/6.IO操作.html","title":"6. IO操作","keywords":"","body":"6. IO操作 6.1 文件IO 字节流InputStream/OutputStream，字符流Reader/Writer： 涉及外部资源的流(如FileInputStream)需主动释放资源；仅涉及内存的流(如ByteArrayInputStream)则可省略。 使用带缓存区的流可以提高IO效率，如BufferedInputStream、BufferedWriter。 File读写 java.io.File可用来描述文件和文件夹： 创建: 文件：file.createNewFile() 目录：file.mkdir()、file.mkdirs(); 删除: 文件：file.delete() 目录：file.delete() 删除空目录，非空目录需递归删除 重命名: file.renameTo(destFile) 可用来移动文件 查询: 物理存在性探测: file.exits() 类型探测: file.isDirectory()、file.isFile() 路径/文件名: file.getAbsolutePath()、file.getCanonicalPath()、file.getName() 文件长度: file.length() 返回字节数 目录子文件表: file.list()、file.listFiles() 分隔符： 路径分隔符：File.pathSeparator，如 \":\" 目录分隔符：File.separator，如 \"/\" // 资源路径：Project/Main/build/resources/main/res.txt 或 target.jar!/res.txt Main.class.getClassLoader().getResource(\"res.txt\"); Main.class.getResource(\"/res.txt\"); // 起进程的路径：Project/Main/ 或 ~/ (在主目录执行:~$ java -jar target.jar) new File(\"./\").getCanonicalPath(); System.getProperty(\"user.dir\"); public static void main(String[] args) throws IOException { String input = Objects.requireNonNull(JMain.class.getResource(\"/res.txt\")).getFile(); // Stream字节流文件拷贝 try (InputStream ins = new BufferedInputStream(new FileInputStream(input)); OutputStream out = new BufferedOutputStream(new FileOutputStream(\"out.txt\"))) { int b; while (-1 != (b = ins.read())) { out.write(b); } } // Reader字符流读取文件 Reader reader = new BufferedReader(new FileReader(\"out.txt\")); try (Writer writer = new BufferedWriter(new OutputStreamWriter(System.out))) { reader.transferTo(writer); } } 文件锁 可用文件锁来控制多进程的资源获取顺序： FileChannel 操作文件的通道，总是在阻塞模式下读写数据 FileLock 文件锁，只能通过FileChannel获取，持锁进程不能重入 void doInFileLock(Runnable runnable) throws IOException { File file = new File(\"./.lock\"); if (!file.exists() && !file.createNewFile()) { return; } synchronized (JMain.class) { // 添加线程锁，防止进程内重入 //noinspection resource RandomAccessFile raf = new RandomAccessFile(file, \"rw\"); try (FileLock ignored = raf.getChannel().lock()) { // 默认是排它锁 // 获取进程锁后，执行任务 runnable.run(); } } } 序列化 通过ObjectInputStream、ObjectOutputStream读写对象，保存数据。 // 序列化 try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data.obj\"))) { out.writeObject(obj0); } // 反序列化 try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data.obj\"))) { obj1 = (User) in.readObject(); } 自动序列化 实现Serializable接口，声明serialVersionUID字段指定版本 public class User implements Serializable { private static final long serialVersionUID = 1L; protected int id; protected String name; protected transient double salary; // transient字段不参与序列化 // 可不保留空构造方法 public User(int id, String name, double salary) { this.id = id; this.name = name; this.salary = salary; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", salary=\" + salary +'}'; } } 自定义序列化 实现Externalizable接口复写流转换接口, 需保留空构造方法反序列化时调用, 支持对数据做一些处理(比如压缩、加密) public class User implements Externalizable { private static final long serialVersionUID = 1L; private int id; private String name; private double salary; // 不参与序列化的字段需手动处理 public User() {} // 保留无参构造器 public User(int id, String name, double salary) { this.id = id; this.name = name; this.salary = salary; } @Override public void writeExternal(ObjectOutput out) throws IOException { out.write(id); // 写出时，保留处理可变长数据长度 out.write(name.getBytes().length); out.write(name.getBytes()); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { id = in.read(); // 读取时，根据可变长数据长度处理 byte[] bytes = new byte[in.read()]; in.read(bytes); name = new String(bytes); } } 6.2 网络 通信术语 URL：protocol://user-info@host:port/path/file?query#anchor IP与域名: IPV4(32Bit): FF.FF.FF.FF IPV6(128Bit): 冒分16进制: FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF 各段可以省略前导0 零位压缩法: 可以把连续的0替换成::(最多一次)，如 FF::1A、::1A、:: 内嵌IPV4: 后32位嵌IPv4，如 ::192.168.0.1、::FF1A:192.168.0.1 域名: DNS服务保存了IP与域名的映射关系 顶级域名: baidu.com 后缀:商业公司com、网络商net、国家地区cn、非盈利组织org、教育单位edu、政府机构gov 二级域名: www.baidu.com 其中www为二级域名。 端口号: 传输层用来区分进程，是[0, 65535]的整数，其中[0, 1023]为系统保留端口。 URL URI(Uniform Resource Identifier)格式形如:[shceme:]scheme-specific-part[#fragment]; URL(Uniform Resource Location)是一种分层URI(由绝对(包含scheme:)且透明(scheme-specific-part以/开头)的URI + 相对URI构成)，可以唯一定位资源。 // 1.Uri标准化解析与编码 URI uri = URI.create(\"https://www.baidu.com/home/index/test?a=1&b=中文#frag\"); uri.getQuery(); uri.toASCIIString(); // 2.绝对地址与相对地址处理 // URI绝对化: https://www.baidu.com/home/java/a.html URI uri1 = uri.resolve(\"../java/a.html\"); // URI相对化: java/a.html URI uri2 = URI.create(\"https://www.baidu.com/home\").relativize(uri1); // URL对象可以简单读取资源 URL url = URI.create(\"https://www.baidu.com/\").toURL(); Scanner cin = new Scanner(new BufferedInputStream(url.openStream())); while (cin.hasNextLine()) { T.d(cin.nextLine()); } // URLConnection提供了更多能力： URLConnection conn = new URL(\"https://www.wanandroid.com/user/login\").openConnection(); conn.setConnectTimeout(5000); conn.setReadTimeout(8000); // request Header conn.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\"); // request Method ((HttpURLConnection) conn).setRequestMethod(\"POST\"); // set post args conn.setDoOutput(true); BufferedOutputStream out = new BufferedOutputStream(conn.getOutputStream()); out.write(new String(\"{\\\"username\\\":\\\"test\\\"}\").getBytes()); // 建立套接字连接，拉取头信息 conn.connect(); // 响应基本数据 int code = ((HttpURLConnection) conn).getResponseCode(); String msg = ((HttpURLConnection) conn).getResponseMessage(); String type = conn.getContentType(); // 响应头 Map> respHeaders = conn.getHeaderFields(); // 响应体 BufferedInputStream resp = new BufferedInputStream(conn.getInputStream()); String respStr = new String(resp.readAllBytes(), \"UTF-8\"); Socket 套接字是设备通信的基础: 接收端通过Socket监听端口读取数据, 发送方通过Socket向目标设备的目标端口发送数据。 InetAddress 支持从DNS服务获取IP、域名； 构建： 支持域名/IP构建：InetAddress.getByName()、InetAddress.getByAddress() 本机地址：InetAddress.getLocalHost() 本地回环：InetAddress.getLoopbackAddress() 获取： IP地址：addr.getAddress():byte[]、addr.getHostAddress():String 主机名：addr.getHostName() 主机别名：addr.getCanonicalHostName() 可达性测试：addr.isReachable(3000) 基于TCP协议的Socket TCP是面向连接的传输协议，链接建立后不会轻易改变，数据传输需要回复确认；UDP是非连接的传输协议，没有链接建立和断开过程，数据传输不需回复确认。 static void createTcpSocketServer() throws IOException { try (ServerSocket server = new ServerSocket(SERVER_PORT)) { while (server.isBound() && !server.isClosed()) { // 阻塞，直到有客户端连接 Socket client = server.accept(); // 新线程中响应请求 new Thread(new Runnable() { @Override public void run() { try (Scanner socketIn = new Scanner(new BufferedInputStream(client.getInputStream()))) { PrintWriter echo = new PrintWriter(new BufferedOutputStream(client.getOutputStream()), true); while (socketIn.hasNextLine()) { // 阻塞，等待输入 String recv = socketIn.nextLine(); if (\"quit\".equalsIgnoreCase(recv) || \"exit\".equalsIgnoreCase(recv)) { break; } echo.println(recv); } client.close(); } catch (IOException e) { e.printStackTrace(); } } }).start(); } } } static void createTcpSocketClient() throws IOException { try (Socket socket = new Socket(InetAddress.getLocalHost(), SERVER_PORT)) { // 客户端在新线程中监听 new Thread(new Runnable() { @Override public void run() { try (Scanner scanner = new Scanner(new BufferedInputStream(socket.getInputStream()))) { while (scanner.hasNextLine()) { String recv = scanner.nextLine(); System.out.println(socket.getInetAddress().getHostAddress() + \": \" + recv); } } catch (IOException e) { e.printStackTrace(); } } }).start(); try (Scanner cin = new Scanner(System.in); PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) { while (!socket.isClosed() && cin.hasNextLine()) { writer.println(cin.nextLine()); } } } } static void createUdpSocket(int port) { try (DatagramSocket socket = new DatagramSocket(port, InetAddress.getLocalHost())) { // 异步接收数据 Thread t = new Thread(new Runnable() { @Override public void run() { byte[] bytes = new byte[1024 * 1024]; // Max 1M DatagramPacket packet = new DatagramPacket(bytes, bytes.length); while (!socket.isClosed()) { try { socket.receive(packet); String msg = new String(Arrays.copyOf(packet.getData(), packet.getLength())); System.out.println(packet.getAddress().getHostAddress() + \":\" + packet.getPort() + \" : \" + msg); } catch (IOException e) { e.printStackTrace(); } } } }); t.setDaemon(true); t.start(); // 输入&发送 String input; Scanner cin = new Scanner(System.in); while (cin.hasNextLine()) { input = cin.nextLine().trim(); if (\"quit\".equalsIgnoreCase(input) || \"exit\".equalsIgnoreCase(input)) break; String[] split = input.split(\"@\"); input = split[0]; if (split.length > 1) port = Integer.parseInt(split[1]); // 发送数据 socket.send(new DatagramPacket(input.getBytes(), input.getBytes().length, InetAddress.getLocalHost(), port)); } } catch (Exception e) { e.printStackTrace(); } } 6.3 数据库 Java通过JDBC连接Mysql 使用过程 加载驱动相关的Class 通过DriverManager和数据库uri构建Connection对象 创建Statement或PreparedStatement执行SQL语句 // 加载驱动相关的class Class.forName(\"com.mysql.cj.jdbc.Driver\");// 8.0以下是：com.mysql.jdbc.Driver // 构建uri，选定 main 仓库 String uri = \"jdbc:mysql://localhost:3306/main?useSSL=true&serverTimezone=UTC\"; // 通过 DriverManager::getConnection 获取 Connection conn = DriverManager.getConnection(uri, \"root\", \"0000\"); /** Statement执行 **/ Statement statement = conn.createStatement(); String sql = \"\"; // 单条执行 boolean res = statement.execute(sql); int cnt = statement.executeUpdate(sql); ResultSet resSet = statement.executeQuery(sql); // 批量执行 statement.addBatch(sql); statement.addBatch(sql); statement.executeBatch(); /** PreparedStatement执行 **/ // 获取预编译语句对象，可以复用 PreparedStatement preparedStatement = conn.prepareStatement(sql); // 设置占位符的值 preparedStatement.setString(0, \"value\"); preparedStatement.executeUpdate(); resSet = preparedStatement.executeQuery(); 结果集 在conn.createStatement()、conn.createPrepareStatement()是可通过参数指定结果集特性： 是否可修改数据： 只读：ResultSet.CONCUR_READ_ONLY 可写：ResultSet.CONCUR_UPDATABLE 行指针移动方式 单向移动：ResultSet.TYPE_FORWARD_ONLY 写入后读保持不变：ResultSet.TYPE_SCROLL_INSENSITIVE 写入后读移动到写入位置：ResultSet.TYPE_SCROLL_SENSITIVE 事务提交后: 保持结果集打开：ResultSet.HOLD_CURSORS_OVER_COMMIT 关闭结果集：ResultSet.CLOSE_CURSORS_AT_COMMIT ResultSet 读取数据: 获取行号：int r = resSet.getRow(); 获取列号：int c = resSet.findColumn(colName) 获取本行某列值：String val = resSet.getString(col) 从数据库同步当前行数据：resSet.refreshRow() 添加数据: 移动到插入行（这是一个空白行）：resSet.moveToInsertRow() 调用更新操作写入字段：resSet.updateXXX(col, xxx) 提交插入事务：resSet.insertRow() 提交删除事务：resSet.deleteRow() 修改数据： 更新值：resSet.updateXxx(col, xx)、resSet.updateNull(col) 取消更新：resSet.cancelRowUpdate() 提交更新事务：resSet.updateRow() 移动游标: 绝对移动： 首行/首行前：resSet.first()、resSet.beforeFirst() 尾行/尾行后：resSet.after()、resSet.afterLast() 具体某行：resSet.absolute(int row)，row==0同beforeFirst() 相对移动： 移动一行：resSet.previous()、resSet.next() 移动N行：resSet.relative(int rows)，rows为正向前移动 特殊位置： 移动到读取行：resSet.moveToCurrentRow()，如果当前在插入行的话 移动到插入行：resSet.moveToInsertRow() // create table m_books( id INT(11) primary key auto_increment, name varchar(120), code varchar(200) ); Statement statement = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); String sql = \"select * from m_books\"; ResultSet resultSet = statement.executeQuery(sql); // 插入 for (int i = 0; i "},"chapter7/7.Java虚拟机.html":{"url":"chapter7/7.Java虚拟机.html","title":"7. Java虚拟机","keywords":"","body":"7. Java虚拟机 7.1 虚拟机结构 Java虚拟机只与Class文件有关联，任何语言(Java,Groovy,Kotlin)只要能编译成Class文件就可被执行。 HotSpotVM：OracleJDK和OpenJDK中自带的虚拟机。 J9VM：多用途虚拟机(服务端、桌面应用、嵌入式)，性能大致和HotSpot VM相当。 Zing VM：启动后会快速预热；Heap可达1TB,GC耗时在10ms以下；配套有监控工具Zing Vision。 7.1.1 JVMM PC寄存器: 保存当前线程下一条待执行指令地址 方法调用栈: HotSpot中两个栈并未区分 Java方法栈: 用于Java方法调用 Native方法栈: 用于native方法调用 堆：保存运行时创建的对象 PSYoungGen: 新生代 Eden: 新对象首先分配到伊甸园区(若对象太大直接放到老年代) S0/S1: MinorGC时把Eden和From-Survivor中的存活对象拷贝到To-Survivor PSOldGen: 老年代，大对象和超过了一定年龄阈值的对象会被放在这里 方法区：JDK8后用本地内存来实现称为Metaspace(JDK7之前用堆的PermGen实现), 类元信息: 包括类型信息、字段信息、方法信息 运行时常量池: 包括类型、字段、方法的直接引用和常量 JIT代码缓存: 保存即时编译器优化后的代码 直接内存: 不由JVM管理，可通过ByteBuffer.allocateDirect():DirectByteBuffer使用。 7.1.2 堆 类在加载后会在方法区保存该类的元数据和常量池，并在堆中创建该类的Class实例。 JDK7+后，静态变量存储在类的Class实例中(之前静态变量也保存在方法区)，为方便内存回收字符串常量池也从方法区移到了堆中。 7.1.3 方法区 类元信息 JVM对每个加载的类型,包括类、接口、枚举、注解类，会在方法区中存放该类型的元数据: 修饰符: public,abstract,final的一个子集 有效名称: 含包名和类名 直接父类有效名、直接接口名的有序列表 JVM保存每个类型的所有字段元信息和声明顺序: 修饰符: public,private,protected,static,final,volatile,transient的一个子集 字段类型签名 字段名 JVM保存类型中所有方法的元信息和声明顺序: 修饰符: public,private,protected,static,final,abstract,synchronized,native的一个子集 方法签名: 包括返回值类型、方法名、入参类型和顺序 非abstract/native的方法还有： 方法体字节码: 字节码指令或指向JIT缓存 局部变量表、操作数栈及它们的大小 try-catch异常表: 表中的项目包括捕获开始位置、捕获结束位置、处理代码指令偏移、该异常类型的运行时常量池索引 运行时常量池 每个.class文件中都包含一个的常量池，包括本文件中用到的: 对其他类/字段/方法的符号引用, 字面常量(字符串、浮点数、比short大的整数)。 JVM为每个加载的类型在运行时常量池中维护该类型的常量池表，而该表中的符号引用会被替换成直接引用(地址或偏移)。 JIT代码缓存 在HotSpotVM中内嵌有两个JIT编译器: Client Compiler(C1编译器)和Server Compiler(C2编译器): C1编译器会对字节码进行简单和可靠的优化，编译速度更快 C2编译器会启动一些编译耗时更长的优化，编译质量更好 方法区GC 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 回收常量池的常量: 常量没有被引用时，可直接回收 卸载不再使用的类: 需满足3个条件1.堆中不再有该类以及派生类的实例 2.该类的Class对象没有被引用了 3.加载该类的类加载器被回收了 注: HotSpot提供了-Xnoclassgc参数控制不卸载类，还可用-verbose:class以及-XX:+TraceClass-Loading、-XX:TraceClassUnLoading查看类加载和卸载信息。 7.1.4 直接内存 直接内存即Native堆，不受JVM管理，在某些和native库通信的场景可避免数据频繁在Java堆和Native堆拷贝带来的消耗。 // 虚引用: 可在子线程中调阻塞方法queue.remove(); 当获取到Reference对象时表明有对象被回收了 ReferenceQueue queue = new ReferenceQueue<>(); PhantomReference ref = new PhantomReference<>(new Object(), queue); // NIO: ByteBuffer，需要添加编译参数: javac --add-exports java.base/sun.nio.ch=ALL-UNNAMED ByteBuffer buffer = ByteBuffer.allocateDirect(100); buffer.put((byte) 0xFF); buffer.put(0, (byte) 0x80); buffer.get(); // 以大端序(地址放高字节)取4B组成一个int: Integer.MIN_VALUE = 0x80000000 int res = buffer.getInt(0); // ByteBuffer内部利用虚引用通知，在GC回收无ByteBuffer对象时释放Native内存 // 也可以手动释放 ((DirectBuffer) buffer).cleaner().clean(); 7.1.5 相关工具 内存分析工具 # 查看JVM进程, jps -l # 查看类加载情况 jstat -class # 统计各内存区间使用情况和GC情况, 间隔1000ms共查询3次 jstat -gc 1000 3 # 查看堆空间使用详情 注意jmap的版本要和jvm版本匹配，或使用: jhsdb sudo jmap -heap sudo jhsdb jmap --heap --pid # dump内存快照,可使用JDK的jvisualvm工具或下载MAT工具分析 jmap -dump:format=b,file=my-dump.bin JVM内存配置参数 # 设置每个线程的Java方法栈大小 -XX:ThreadStackSize -Xss128k # 初始堆大小 -Xms512m 相当于 -XX:InitialHeapSize=512m # 最大堆大小 -Xmx2g 相当于 -XX:MaxHeapSize=2g # 设置堆中年轻代的大小，固定值 -Xmn2g # 新生代比例, 值为2时表示年轻代:老年代=1:2 -XX:NewRatio=2 # 幸存者比例, 值为8时表示 Eden:S0:S1 = 8:1:1 -XX:SurvivorRatio=8 # 对象进入老年代的年龄阈值 -XX:MaxTenuringThreshold=15 # 初始的元空间大小(64位通常21MB)，将满时触发FullGC卸载无用的类，之后重新调整阈值 -XX:MetaspaceSize=21m # 最大元空间值，不限制表示最大可耗尽系统内存 -XX:MaxMetaspaceSize=-1 # 输出jvm载入类的相关信息，当jvm报告说找不到类或者类冲突时可此进行诊断。 -verbose:class # 指定JIT编译器 -client -server # 显示GC详情 -verbose:gc -XX:+PrintGCDetails # 查看参数默认值 java -XX:+PrintCommandLineFlags -version java -XX:+PrintFlagsFinal -version # 查看某进程参数 jinfo -flags jinfo -flag InitialHeapSize 7.2 类加载 Class文件 符号引用：用符号来描述所引用的目标，与JVM的内存布局无关。符号引用存在于class文件中。 直接引用：以一个地址表示引用的目标，与虚拟机的内存布局相关，且指向的目标一定已经加载到内存中了。 // 可通过 javap -v ClassName 查看 // ux 代表无符号，x字节 ClassFile{ u4 magic; // 0XCAFEBABE，是否能被JVM处理的标志 u2 major_version; // 主版本 u2 minor_version; // 副版本 // 常量池相关 u2 const_pool_cnt; cp_info const_pool[const_pool_cnt - 1]; // 继承相关 u2 access_flags; // 层次访问标志 u2 super_class; // 父类索引 u2 this_class; // 类索引 // 接口相关 u2 interfaces_cnt; u2 interfaces[interfaces_cnt] // 字段相关 u2 fields_cnt; field_info fields[fields_cnt]; // 方法相关 u2 methods_cnt; method_info methods[methods_cnt]; // 属性相关，如SourceFile表示从哪个源文件编译的 u2 attrs_cnt; attribute_info attrs[attrs_cnt]; } 类加载过程 加载：Classloader根据特定的名称在路径中查找类或接口的.class文件 链接： 验证：验证.class文件内容确保数据正确。 准备：为静态字段分配默认的0值。 解析：把.class文件转为方法区的运行时数据结构(即Klass对象，其中的符号引用会被替换为直接引用), 并在堆中生成这个类的Class对象(即oop实例)保存到Klass#_java_mirror 初始化：执行由于静态变量赋值、静态块合成的()方法。 // Klass和oop是相互指向的: _java_mirror -> Class实例头Klassword -> Klass实例 // 以下寻找过程: 向由对象头的Klassword找到方法区Klass实例，再经_java_mirror找到对中的Class对象 Class c = new Object().getClass(); 类加载器 类加载器采用双亲委派模型(优先让父类加载),同一个类若由不同的Classloader加载Class对象是不同的。 BootstrapClassLoader: 加载JDK的核心类，Java无法访问; 路径$JAVA_HOME$/jre/lib/、-Xbootclasspath、sun.boot.class.path ExtClassLoader: 核心类之外的系统类; 路径$JAVA_HOME$/jre/lib/ext/、java.ext.dirs AppClassLoader: 当前应用Classpath; 路径java.class.path, 获取LoaderClassLoader.getSystemClassLoader() 注: System.getProperty(key)可通过JVM启动参数-Dkey指定，但需注意这样会覆盖默认值。 7.3 对象内存布局和生命周期 对象的内存布局 对象头部: Mark word: JVM字长(32b或64b)，在不同锁状态下结构也不同，内容包含了 hash: 哈希值25b/31b, 调用obj.hashCode()/System.identityHashCode(obj)后才生成; age: 分代年龄4b,故-XX:MaxTenuringThreshold最大值为15 biased_lock: 偏向锁标识1b lock: 锁状态2b thread: 持有偏向锁的线程ID epoch: 配合Class对象中的epoch字段用于禁用偏向(重偏撤销过多开销过大) ptr_to_lock_record: 轻量级锁状态下，指向栈中锁记录的指针 ptr_to_heavyweight_monitor: 重量级锁状态下，指向对象监视器Monitor的指针 Klass word: JVM字长，指向方法区中当前对象所属的类元数据,即Klass对象。 Array length: 仅数组对象才有，默认为JVM字长，开启指针压缩后固定为32b 实例字段/数组元素: 1.相同宽度的字段一起存放，父类字段在子类字段前，按声明顺序排布。 对齐填充: HotSpot要求对象起始地址必须是整数倍8B，即对象的大小必须是N*8B；。 Object obj = new Object() { short x = 0; }; // JVM64: (8+4) +2 +2 = 16B // ClassLayout在 org.openjdk.jol:jol-core:0.16 obj.hashCode(); System.out.println(ClassLayout.parseInstance(obj).toPrintable()); boolean[] arr = new boolean[29]; // (8+4+4) + 29 + 3 System.out.println(ClassLayout.parseInstance(arr).toPrintable()); 指针压缩 64位JVM使用64位的指针将浪费大量内存(+50%)。为了节约内存JVM默认启用了-XX+UseCompressedOops压缩指针至32位： 静态变量、成员变量、对象数组元素指针 会被压缩至32位(Spothot中对象对齐8B，即一次读取64b，所以32位指针能访问2^32*2^3*2^3=32GB内存) 但局部变量、函数出入参、非Heap对象指针不会被压缩。 对象锁膨胀 偏向锁: JDK15+默认已经禁用偏向锁，可用-XX:+UseBiasedLocking打开 获取: 当所属类的Class对象中未标记不可偏向时,若对象为无锁状态且头部无hash,或已为偏向锁状态; 尝试以CAS方式设置头部thread为当前线程ID, 若失败则等JVM膨胀锁 释放: 持锁线程不会主动释放，但当有线程竞争时，持锁线程运行到SafePoint时STW,锁会根据线程是否已出同步块而被膨胀为轻量级锁 或 解除偏向关联 轻量级锁: 运行到同步块时不会立即挂起线程切换到内核态 获取: 当对象是无锁状态时(或从偏向锁膨胀), 在当前线程栈中开辟解释帧存放锁记录(拷贝了Mark Word), 再以CAS方式更新对象头, 若失败先自旋再失败膨胀锁。 当对象是轻量锁状态, 若ptr_to_lock_record指向当前线程栈,则表示已获取, 否则将膨胀锁为重量级锁并挂起当前线程 释放: CAS方式从LockRecord中恢复对象头的MarkWord, 若失败则意味着锁已膨胀，则根据ptr_to_heavyweight_monitor唤起一个挂起线程 重量级锁: 运行到同步块时会切换到内核态由OS调度 获取: 当锁从轻量锁膨胀时, 创建Monitor对象(也称内部锁)将MarkWord拷贝进去,再将当前线程放入队列等待, 并以CAS更新对象头后切到内核态, 若失败则重新尝试获取锁 释放: 若队列非空则唤醒下一个线程，若为空SpotHot会尝试将MarkWord恢复到无锁状态 注: 当对象头已是偏向锁状态，再生成Hash会使对象头部切换到重量锁状态,因为要在堆中构建Monitor对象来存放MarkWord 若同步块中有使用wait()/notify()方法，则对象锁只能是重量级锁 对象的生命周期 被创建Created：初始化和并执行完构造方法 使用中In Use：存在至少一个强引用 *不可见Invisible：虽然还有强引用，但强引用以已不可访问(指令已出作用域) 不可达Unreachable：GCRoots的强引用链不可达 被收集Collected：GC准备重新分配该内存空间，调用obj.finalize()前 被终结Finalized：执行完obj.finalize()仍然不可达，就等待GC回收 消亡Deallocated：内存被GC回收或重新分配 注: 若发生内存泄漏(Memory Leak,不再使用的对象无法回收)，容易导致内存溢出(Memory Overflow,内存不够使用而崩溃) 对象的创建过程 生成/查找Class对象：根据类名(主类名、符号引用)执行类加载、链接、初始化，取得Class对象。 分配内存: 先尝试在TLAB(Thread Local Allocation Buffer)分配，若不够就更换TLAB或在TLAB外分配。 内存初始化: 所有内存值初始化为0。 设置对象头: Mark word、Klass word、Array length。 先执行由成员变量赋值、构造块合成的()方法，再执行构造方法。 注: 所以初始化的顺序是: 静态变量赋值、静态块执行(()) > 成员变量赋值、构造块执行(()) > 构造方法。 TLAB与栈上分配 TLAB用3个指针(start:top:end)表示Eden中的区域(大小约占1%), 仅Owner线程可分配内存以减少同步等待；线程创建时分配一个TLAB但GC后失效。 Hotspot在C2编译器中支持逃逸分析(Escape Analysis)，对没有线程逃逸的代码做锁消除，对没有方法逃逸的代码做标量替换以实现栈上分配。 垃圾收集器(GC) 用来分配内存、回收不再引用的对象。可以通过VM启动参数-XX:+PrintGCDetails查看GC日志。 Java有4种类型的引用： 强引用: 宁愿抛OOM也不回收 SoftReference: 软引用,无强引用只剩软引用的对象在内存不足时回收 WeakReference: 弱引用,无强引用只剩弱引用的对象GC一旦发现即会回收 PhantomReference: 虚引用,对象被回收时会添加到引用队列 (1)垃圾标记 可达性算法：选定一些对象作为GC Roots根集，向下搜索标记可达与否。GC Roots对象包括： 被Java方法栈/Native方法栈中引用的对象。 被静态字段引用的对象(static成员)。 JNI的全局变量。 所有的运行中没停止的线程对象(thread)。 由Bootstrap Classloader加载的类的实例或其他被GC标记Root的对象。 (2)分代收集 新生代PSYoungGen：MinorGC, 先把Eden和From-Survivor中存活的对象复制到To-Survivor(age+1)，再调换Survivor。 新生代可细分：Eden:S1:S2 在HotSpot默认为8:1:1； 若复制时 (1)对象分代年龄超过晋升值-XX:MaxTenuringThreshold (2)To Survivor空间已满，则对象直接晋升为老年代。 老年代ParOldGen：FullGC, 先在新生代执行MinorGC，再对老年代执行标记-清除(累计若干次标记清除后改执行标记-压缩)。 注: 复制算法：每次把存活的对象复制到另外一半内存，适用于存活对象少的新生代。 标记-清除(Mark-Sweep)：对不可达的对象，直接清除(地址段放入闲散空间列表)；会产生较多碎片。 标记-压缩(Mark-Compact)：把存活的对象重新排列，回收剩下的内存。 对象池 String池: 字面常量在类加载的链接阶段就放到池中了，也可通过String.intern()向池中添加元素。 Integer池: 对于一个字节内的整型数据-128~127，其包装对象是同一个。 对象析构 对象在被收集前会调用finalize()但已不建议使用，而应使用基于虚引用实现的Cleaner Object obj = new Object(); Cleaner c = Cleaner.create(); Cleaner.Cleanable cleanable = c.register(obj, new Runnable() { @Override public void run() { // 对象被回收时调用,不论主动被动只会回调一次 System.out.println(\"obj gc\"); } }); // 主动释放资源 cleanable.clean(); obj = null; System.gc(); // 不建议手动调用gc "},"chapter8/8.工具附录.html":{"url":"chapter8/8.工具附录.html","title":"8. 工具附录","keywords":"","body":"8. 工具附录 8.1 数组工具 Arrays为数组提供了一系列工具，Collections为集合类提供了一系列工具。 // 填充 Arrays.fill(array , from , to , value); // 逐字节赋值 System.arraycopy(src,startIndex,des,startIndex,length); // 默认排升序 Arrays.sort(array,from,to); // 二分查找 Arrays.binarySearch(array, fromIndex, toIndex, key); // 逐元素调equals Arrays.deepEquals(array1, array2); // 逐元素调toString Arrays.deepToString(array); 8.2 数值转换和随机 进制转换 // ibase=2 Integer i = Integer.parseInt(\"1111011\", 2); // obase=16 String ans = Integer.toString(i, 16); System.out.println(ans); 随机数 Random random = new Random(System.currentTimeMillis()); // 返回 [0, 100) 的随机整数 random.nextInt(100); // 返回 [0, 1) 的随机浮点数 double r = Math.random(); // 返回 [100, 200) 的随机整数 int ans = (int) (r * 100 + 100); 8.3 日期时间处理 系统时间：System.currentTimeMillis() 单位毫秒 单调时间：System.nanoTime() 自JVM启动以来的绝对单调时间，最长292年(2^62纳秒) 涉及年月日周时使用Calendar.getInstance() 注意月份[0, 11] long ts; Date date; String text; /**时间戳与Date转换**/ ts = System.currentTimeMillis() + javax.management.timer.Timer.ONE_DAY; date = new Date(ts); ts = date.getTime(); /**字符串与时间转换**/ text = \"2016/11/30 15:30:00\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\"); date = sdf.parse(text); text = sdf.format(date); 8.4 正则表达式 关于转义： 转义符\\体现为\"\\\\\"，如\\d写为\"\\\\d\" 原始\\字符写为\"\\\\\\\\\" String input = \"This is for every one\"; String regex = \"(\\\\w+)\"; // 编译 Pattern pattern = Pattern.compile(regex); // 绑定正则与文本 Matcher matcher = pattern.matcher(input); // 校验，同 input.matches(regex); boolean valid = matcher.matches(); // 切割，同 input.split(\" \"); String[] splits = pattern.split(input); // 替换，同 input.replaceAll(regex, \"@@@\"); T.d(matcher.replaceAll(\"@@@\")); // 查找 int start = 0; while (start 8.5 Robot Java支持使用Robot构建自动化工具(Unix系统需要权限)，模拟用户操作，并截图保存; Logger支持各种级别的日志记录。 // 图形环境 GraphicsEnvironment eir = GraphicsEnvironment.getLocalGraphicsEnvironment(); // 图形设备(显示器) GraphicsDevice device = eir.getDefaultScreenDevice(); // 键盘输入 Robot robot = new Robot(device); robot.delay(3000); // 延迟2s robot.keyPress(KeyEvent.VK_META); // Mac CMD robot.keyPress(KeyEvent.VK_H); robot.keyRelease(KeyEvent.VK_META); robot.keyRelease(KeyEvent.VK_H); // 鼠标输入 robot.mouseMove(10, 10); robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK); robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK); // 截图保存 BufferedImage img = robot.createScreenCapture(new Rectangle(device.getDisplayMode().getWidth(), device.getDisplayMode().getHeight())); File file = new File(\"img.png\"); ImageIO.write(img, \"png\", file); // 日志记录 T.d(Main.class.getName()); Logger logger = Logger.getLogger(Main.class.getName()); logger.setLevel(Level.ALL); // 最低记录级别 logger.addHandler(new FileHandler(\"./log\", 1000, 1, false)); logger.addHandler(new Handler() { // StreamHandler @Override public void publish(LogRecord record) { System.out.println(record.getMessage()); } @Override public void flush() { } @Override public void close() throws SecurityException { } }); logger.setFilter(new Filter() { @Override public boolean isLoggable(LogRecord record) { // log all return true; } }); logger.entering(\"com.chavin.Main\", \"main\"); logger.info(\"Hello\"); logger.logp(Level.WARNING, \"com.chavin.Main\", \"main\", \"World\"); logger.exiting(\"com.chavin.Main\", \"main\"); "}}