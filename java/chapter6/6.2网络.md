# 6.2 网络

## 通信术语
- URL：`protocol://user-info@host:port/path/file?query#anchor`
- IP与域名:
    - IPV4(32Bit): `FF.FF.FF.FF`
    - IPV6(128Bit): 
        - 冒分16进制: `FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF` 各段可以省略前导0
        - 零位压缩法: 可以把连续的0替换成`::`(最多一次)，如 `FF::1A`、`::1A`、`::`
        - 内嵌IPV4: 后32位嵌IPv4，如 `::192.168.0.1`、`::FF1A:192.168.0.1`
    - 域名: DNS服务保存了IP与域名的映射关系
        - 顶级域名: `baidu.com` 后缀:商业公司`com`、网络商`net`、国家地区`cn`、非盈利组织`org`、教育单位`edu`、政府机构`gov`
        - 二级域名: `www.baidu.com` 其中`www`为二级域名。
- 端口号: 传输层用来区分进程，是`[0, 65535]`的整数，其中`[0, 1023]`为系统保留端口。


## URL
URI(Uniform Resource Identifier)格式形如:`[shceme:]scheme-specific-part[#fragment]`; URL(Uniform Resource Location)是一种分层URI(由绝对(包含`scheme:`)且透明(scheme-specific-part以`/`开头)的URI + 相对URI构成)，可以唯一定位资源。

```java
// 1.Uri标准化解析与编码
URI uri = URI.create("https://www.baidu.com/home/index/test?a=1&b=中文#frag");
uri.getQuery();
uri.toASCIIString();

// 2.绝对地址与相对地址处理
// URI绝对化: https://www.baidu.com/home/java/a.html
URI uri1 = uri.resolve("../java/a.html");
// URI相对化: java/a.html
URI uri2 = URI.create("https://www.baidu.com/home").relativize(uri1);

// URL对象可以简单读取资源
URL url = URI.create("https://www.baidu.com/").toURL();
Scanner cin = new Scanner(new BufferedInputStream(url.openStream()));
while (cin.hasNextLine()) {
    T.d(cin.nextLine());
}

// URLConnection提供了更多能力：
URLConnection conn = new URL("https://www.wanandroid.com/user/login").openConnection();
conn.setConnectTimeout(5000);
conn.setReadTimeout(8000);

// request Header
conn.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
// request Method
((HttpURLConnection) conn).setRequestMethod("POST");
// set post args
conn.setDoOutput(true);
BufferedOutputStream out = new BufferedOutputStream(conn.getOutputStream());
out.write(new String("{\"username\":\"test\"}").getBytes());

// 建立套接字连接，拉取头信息
conn.connect();

// 响应基本数据
int code = ((HttpURLConnection) conn).getResponseCode();
String msg = ((HttpURLConnection) conn).getResponseMessage();
String type = conn.getContentType();
// 响应头
Map<String, List<String>> respHeaders = conn.getHeaderFields();
// 响应体
BufferedInputStream resp = new BufferedInputStream(conn.getInputStream());
String respStr = new String(resp.readAllBytes(), "UTF-8");
```

## Socket
套接字是设备通信的基础: 接收端通过Socket监听端口读取数据, 发送方通过Socket向目标设备的目标端口发送数据。

### InetAddress
支持从DNS服务获取IP、域名；

- 构建：
    - 支持域名/IP构建：`InetAddress.getByName()`、`InetAddress.getByAddress()`
    - 本机地址：`InetAddress.getLocalHost()`
    - 本地回环：`InetAddress.getLoopbackAddress()`
- 获取：
    - IP地址：`addr.getAddress():byte[]`、`addr.getHostAddress():String`
    - 主机名：`addr.getHostName()`
    - 主机别名：`addr.getCanonicalHostName()`
- 可达性测试：`addr.isReachable(3000)`

### 基于TCP协议的Socket
TCP是面向连接的传输协议，链接建立后不会轻易改变，数据传输需要回复确认；UDP是非连接的传输协议，没有链接建立和断开过程，数据传输不需回复确认。

```java
static void createTcpSocketServer() throws IOException {
    try (ServerSocket server = new ServerSocket(SERVER_PORT)) {
        while (server.isBound() && !server.isClosed()) {
            // 阻塞，直到有客户端连接
            Socket client = server.accept();
            // 新线程中响应请求
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try (Scanner socketIn = new Scanner(new BufferedInputStream(client.getInputStream()))) {
                        PrintWriter echo = new PrintWriter(new BufferedOutputStream(client.getOutputStream()), true);
                        while (socketIn.hasNextLine()) {
                            // 阻塞，等待输入
                            String recv = socketIn.nextLine();
                            if ("quit".equalsIgnoreCase(recv) || "exit".equalsIgnoreCase(recv)) {
                                break;
                            }
                            echo.println(recv);
                        }
                        client.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}

static void createTcpSocketClient() throws IOException {
    try (Socket socket = new Socket(InetAddress.getLocalHost(), SERVER_PORT)) {
        // 客户端在新线程中监听
        new Thread(new Runnable() {
            @Override
            public void run() {
                try (Scanner scanner = new Scanner(new BufferedInputStream(socket.getInputStream()))) {
                    while (scanner.hasNextLine()) {
                        String recv = scanner.nextLine();
                        System.out.println(socket.getInetAddress().getHostAddress() + ": " + recv);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        try (Scanner cin = new Scanner(System.in);
                PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) {
            while (!socket.isClosed() && cin.hasNextLine()) {
                writer.println(cin.nextLine());
            }
        }
    }
}

static void createUdpSocket(int port) {
    try (DatagramSocket socket = new DatagramSocket(port, InetAddress.getLocalHost())) {
        // 异步接收数据
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                byte[] bytes = new byte[1024 * 1024]; // Max 1M
                DatagramPacket packet = new DatagramPacket(bytes, bytes.length);
                while (!socket.isClosed()) {
                    try {
                        socket.receive(packet);
                        String msg = new String(Arrays.copyOf(packet.getData(), packet.getLength()));
                        System.out.println(packet.getAddress().getHostAddress() + ":" + packet.getPort() + " : " + msg);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        t.setDaemon(true);
        t.start();

        // 输入&发送
        String input;
        Scanner cin = new Scanner(System.in);
        while (cin.hasNextLine()) {
            input = cin.nextLine().trim();
            if ("quit".equalsIgnoreCase(input) || "exit".equalsIgnoreCase(input)) break;
            String[] split = input.split("@");
            input = split[0];
            if (split.length > 1) port = Integer.parseInt(split[1]);
            // 发送数据
            socket.send(new DatagramPacket(input.getBytes(), input.getBytes().length,
                    InetAddress.getLocalHost(), port));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
