# 3.1 类型擦除

类型参数化，即允许以参数形式传入不同类型，而复用其他和具体类型无关的逻辑。最终类型参数在编译时会用第一个限定类型擦除(没有限定用`Object`)。

*注*: Java的泛型是不型变的，即对于`Wrapper<A>`和`Wrapper<B>`，不论类型`A`和`B`是否相容，`Wrapper<A>、Wrapper<B>`都不相容。

```java
class Wrapper<T extends CharSequence & Comparable<T>> implements Comparable<Wrapper<T>> {
    T data;

    Wrapper() {
    }

    public int dataLength() {
        // 复用 CharSequence::Length
        return this.data.length();
    }

    @Override
    public int compareTo(Wrapper<T> o) {
        // 复用 Comparable::compareTo
        return this.data.compareTo(o.data);
    }
}
```

## 泛型和Object对比
- 泛型在编译期会检查受检类型的相容性，对于不相容的类型会编译失败, 具有更好的安全性和可读性；
- Object在运行时才检查类型相容（如,`A a = (A) obj;`），不相容会抛出`ClassCastException`

```java
// 泛型类或接口
class Wrapper<T>{
    T data;
}

// 泛型方法
public <T> void act(T arg){ }

```

## 泛型使用的限制
1. 不能创建泛型数组: 不能`new List<Object>[10];` 但可以`new List<?>[10]` 、`new List[10]`
2. 不能创建占位符类型实例、捕获未知类型异常: `new T();`、`try{ }catch(T e);`
3. 不能声明静态泛型成员: `static T var;`
4. 涉及类型的操作只支持原始类型
    - 实例判断：`list instanceof List<?>`
    - 强制转换：`List<?> list = (List<?>) arrayList;`
    - Class对象：`list.getClass() == ArrayList.class`

