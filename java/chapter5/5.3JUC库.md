# 5.3 J.U.C库

由于同步锁性能消耗大，而`volatile`只能保证可见性而无法保证原子性；现代CPU提供了硬件级指令实现同步原语(`java.util.concurrent.*`基于CAS性能更好)：

```java
// 如Intel: cmpxchg，以下假设当前内存值为V，预期值为A，待设置值为B
// 其逻辑形如
while(true){
    if (isOtherWriting) continue; // 检测到其他线程在写值，自旋(而非阻塞)
    if (V == A) { // CPU保证在 [V==A之后, 设置V=B前]不会有其他线程修改V值 
        isOtherWriting = true
        setV(B);
        isOtherWriting = false    
    }
    // 预期值不符，设置失败
    break;
}
```

## 原子类AtomicXxx
通过CAS解决变量因多线程并发读写导致的数据异常

```java
AtomicReference<String> ref = new AtomicReference<>("A");
ref.compareAndSet("A", "B");
```

### 竞争分量XxxAccumulator
CAS在大量线程竞争时会不停自旋导致消耗过大，竞争分量通过分段的思想，将不同线程更新不同的段，最后再将各段合并进而提高效率。

```java
// Adder: LongAdder, DoubleAdder
// Accumulator: LongAccumulator, DoubleAccumulator
// 初始化
LongAdder adder = new LongAdder();
// 子线程基于分量计算在单线程模型上保证原子性)
adder.add(x); // adder.increment();
// 计算完毕后合并分量取结果
adder.sum();
```

### 版本引用AtomicXxxReference
CAS会存在ABA问题，通过为对象引用设置版本号来解决将先后两个A错误地认为是同一个对象问题。

```java
// AtomicMarkableReference 使用Boolean值做"版本号"
AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);
ref.compareAndSet("A", "B", ref.getStamp(), ref.getStamp() + 1);
ref.compareAndSet("B", "A", ref.getStamp(), ref.getStamp() + 1);
```

## 线程安全集合
- 用集合对象做锁集合: `Collections.synchronizedCollection/synchronizedMap();`、`Vector<E>`、`Statck<E>`、`Hashtable<K,V>`、`StringBuffer`
- 性能更好的集合: 
    - `CopyOnWriteArraySet/CopyOnWriteArrayList`: 写入之前先拷贝一份出来给读使用
    - `ConcurrentHashMap`: 用更细粒度的锁减少冲突


## J.U.C阻塞队列
阻塞队列在队列的基础上支持两个附加操作：
1. 队列为空时，取元素的线程会等待，直到队列非空
2. 队列已满时，加元素的线程会等待，直到队列可添加元素

```java
/** 抛出异常 **/
    boolean add(e);
    E remove();
    E element();
/** 返回特殊值(非阻塞) **/
    boolean offer(e); // 入队失败返回false; 
    E poll(); // 出队失败返回null
    E peek(); // 检查失败返回null

/** 超时退出(非持续阻塞) **/
    boolean offer(e, time, unit);
    E poll(time, unit);

/** 持续阻塞 **/
    put(e); // 队满时等待条件
    E take(); // 队空时等待条件
```

### 阻塞队列成员
- `ArrayBlockingQueue`: 有界/数组; 默认非公平锁
- `LinkedBlockingQueue`: 可选有界/链表; 读写分锁
- `PriorityBlockingQueue`: 无界/堆; 优先级队列
- `DelayQueue`: 无界/堆; 元素超时才可取出，可用于缓存系统、定时任务`ScheduledThreadPool`
- `SynchronousQueue`: 有界/无; 默认非公平锁, 每个put都须等一个take, 应用：`CachedThreadPool`
- `LinkedBlockingDeque`: 无界/链表; 支持双向读写(但锁是同一个)
- `LinkedTransferQueue`: 无界/链表; 在阻塞队列基础上多了`transfer(e)/tryTransfer(e)`方法

```java
LinkedTransferQueue<String> queue = new LinkedTransferQueue<>();
// 若有消费线程等待立即传递，否则元素插入队尾阻塞生产线程直到被取走
queue.transfer("");
// 若有消费线程等待立即传递，否则返回false元素不进队列
queue.tryTransfer("");
// 若有消费线程等待立即传递，否则元素进队尾阻塞若干时长，若期间被取走返回true否则超时时返回false
queue.tryTransfer("", 1000, TimeUnit.MILLISECONDS);
```


## FutureTask
FutureTask可将Callable转换成Runnable交给线程执行，并可通过Future接口获取执行结果。

![FutureTask](../.asset/future-task.png)

```java
FutureTask task = new FutureTask<>(callable);
new Thread(task).start();
result = task.get(); // 阻塞当前线程
```
