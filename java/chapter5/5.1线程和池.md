# 5.1 线程和池

JVM进程启动后，会启动一个MAIN线程和GC守护线程。

## 线程状态
1. 创建`New`: 尚未执行`start()`方法
2. 就绪`Runnable`: 等待OS调度运行
3. 阻塞`Blocked`: 等待获取到资源
4. 等待`Waiting`: 主动放弃CPU(休眠,礼让,等待条件)等待被唤醒
    - `thread#join();` 放弃锁进入Waiting,直到`thread`跑完才进入Runnable
    - `lock#wait();` 放弃锁进入Waiting,直到获取到lock的条件才进入Runnable
    - `Thread::sleep();` 保持锁进入Waiting,超时后转Runnable等调度
    - `Thread::yield();` 保持锁进入Runnable,等待调度(只礼让高优先级)
5. 终止`Terminated`: 线程自然终止或异常死亡

![线程状态切换](../.asset/threadState.png)


## 线程中断
- `thread.interrupt();`: 将中断标记true(若正在`sleep()/wait()`等中断方法时,用异常打断)
- `thread.isInterrupted();`: 返回中断标记,无副作用;
- `Thread::interrupted();`: 返回中断标记,并把中断标记复位为false;

```java
Runnable runTask = new Runnable(){
    public void run(){
        // 检查中断标记
        while(!Thread.currentThread().isInterrupted()){
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                // 外部调interrupt()抛异常中断本线程,中断标记需手动置为true
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

## 线程访问变量
- 可见性：A线程的缓存对B线程不可见。
- 原子性：JVM只保证**基本数据类型的读取和赋值**是原子操作。
- 有序性：指令重排(`.class`/汇编/CPU指令)遵循happens-before规则，同as-if-serial语义，即线程的执行结果和排序前一致，即有数据依赖关系的指令不会被重排。

```java
// final 保证final的变量在读取前其赋值操作已经完成。
// volatile 确保volatile写操作前后有屏障，并刷新主存、标记各线程缓存失效。
// synchronized 确保在获取和释放锁的时候都有内存屏障，且刷新主存并标记缓存失效。
// 原子类型 基于`UnSafe`类直接操作内存，禁止该指令与前后的指令重排序，并刷新主存并标记缓存失效。

// ThreadLocal变量在线程中是独立的，不同线程互不干扰;
ThreadLocal<SimpleDateFormat> format = ThreadLocal
                .withInitial(()->new SimpleDateFormat("yyyy-MM-dd"));
// 第一次使用会初始化并保存在ThreadLocalMap中, 之后使用本线程不再初始化直到线程被销毁
format.get();
```

![ThreadLocal原理](../.asset/threadLocal.png)

*注:* Key是虚引用ThreadLocal,该对象销毁后JVM会在`get()/set()/remove()`时清理`Key.get()==null`的Entry(即使这样仍然可能内存泄露);


## 线程优先级
- 优先级：`Thread#setPriority(Thread.NORMAL_PRIORITY)` 此优先级在Linux下无效
   - 在`start()`前设置`[10,1]`,值越大优先级越高;
   - 默认父线程优先级,见`Thread#init();`
   - `Thread.yield()`只会礼让优先级相同或更高的线程;
- 守护线程：`Thread#isDaemon();Thread#setDaemon(boolean)`：
   - 后台通用服务,并非不可或缺(例如:GC)
   - 若进程只剩守护线程会被杀死,所以守护线程中读写文件容易损坏数据。


## 线程池
通过对象池复用方案来解决：频繁地线程创建、销毁带来的不必要损耗；控制对象数量以抑制内存上涨。

```java
ThreadPoolExecutor(
    // 核心线程数,核心线程一直存活(即使空闲,除非allowCoreThreadTimeout(true))
    corePoolSize, 
    // 最大线程数
    maximumPoolSize, 
    // 非核心线程闲置时长,超时线程会被回收
    keepAliveTime, 
    // 时间单位,可用TimeUnit.MILLISECONDS
    timeUnit, 
    // 任务队列,BlockingQueue<Runnable>
    workQueue,
    // 线程创建工厂
    threadFactory, 
    // 任务拒绝处理器, 默认ThreadPoolExecutor.AbortPolicy抛异常;
    rejectedExecutionHandler);
```

![线程池工作流程](../.asset/thread-pool.png)

### 内置的线程池
- `FixedThreadPool`：适用请求频繁,数量基本固定的任务(固定核心线程数无超时关闭，无非核心线程，无限任务队列持续等待)
- `CachedThreadPool`：适用数量庞大,耗时较少的任务(无核心线程，无限非核心线程(MAX_INT)超时60s关闭，空任务队列立即执行)
- `SingleThreadPool`：单线程模型用于避免并发时数据不同步问题(单核心线程，无非核心线程，无限任务队列持续等待)
- `ScheduledThreadPool`：适用于定时或周期性任务(核心线程数固定无超时关闭，无限非核心线程(MAX_INT)空闲即回收，空任务队列立即执行)
    - `Timer`：基于系统绝对时间，单线程实现，某个任务执行(时长，异常)会影响其他任务调度。
    - `ScheduledThreadPoolExecutor`：基于相对时间，多线程实现，某个任务执行(时长，异常)不影响其他任务。

```java
ScheduledExecutorService service = new ScheduledThreadPoolExecutor(5);
// 周期执行,下次执行时间 = 本次任务开始时间 + 周期长
service.scheduleAtFixedRate(exeRun,0,1000,TimeUnit.MILLISECONDS);
// 周期执行,下次执行时间 = 本次任务结束时间 + 周期长
service.scheduleWithFixedDelay(exeRun,0,1000, TimeUnit.MILLISECONDS);
```
