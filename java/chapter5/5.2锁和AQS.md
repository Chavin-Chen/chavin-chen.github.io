# 5.2 锁和AQS

`synchronized`锁住的是对象(对象头中包含锁状态), 只有一个竞争条件(`wait()/notify()`方法依赖JVM中Native层管程Monitor对象)。

- 可重入：内层方法默认具有外层方法的获得的锁(锁设计为按线程区分而非方法)。
- 非公平：OS为保证吞吐量，获得锁的顺序不一定同申请顺序(对象锁是非公平锁，AQS则可指定公平)。
- 读写锁：读读共享，读写互斥。
- 分段锁：`ConcurrentHashMap`在JDK7-对每个段加锁(DK8+对每个Entry加锁)以减少冲突提高吞吐。

## AbstractQueuedSynchronizer
- `ReentrantLock`基于AQS实现独占锁，可构建公平或非公平锁。
- `CountDownLatch`基于AQS逆用共享锁机制，实现异步闩。

```java
/** ReentrantLock **/
    ReentrantLock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    // 用tryLock()代替lock.lock()发生死锁时可超时终止
    // lock.lockInterruptibly()无休止尝试直到被interrupt();
    if (lock.tryLock(3000, TimeUnit.MILLISECONDS)) { 
        try {
            if (不满足业务条件) {
                condition.await();
                // 等待被唤醒: condition.signalAll();
            }
            // 获取锁成功, do ...
        } finally {
            lock.unlock();
        }
    } else { //
        // 获取锁超时, do ...
    }

/** CountDownLatch **/
    // 初始化,指定开闩任务数
    CountDownLatch latch = new CountDownLatch(4);

    // 指派子任务完毕,关闩; 线程阻塞于此
    latch.await();

    // 子任务执行完毕,通知开闩
    latch.countDown(); 
```
