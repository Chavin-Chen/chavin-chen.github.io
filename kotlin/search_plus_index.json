{"./":{"url":"./","title":"1. Kotlin简介","keywords":"","body":"1. Kotlin简介 1.1 概述 Kotlin(俄罗斯岛屿名)由JetBrains设计开发的静态类型语言，支持JVM/ART、JS Engine、NativeCode方式运行。 兼容Java，比Java更安全(空指针检测)、更简洁(类型推导、函数式)，比Scala(数据领域Spark、Kafka、Akka项目的开发语言)更容易上手。 官方文档: https://kotlinlang.org/docs/home.html 中文站: https://www.kotlincn.net/docs/reference 开源库: https://github.com/jetbrains/kotlin 编译运行 注: 得到.class文件后，可使用jd-gui反编译查看Java代码。也可在IDEA中:Tools-Kotlin-Bytecode-Decompile // 环境安装 brew install kotlin // (1)编译生成 MainKt.class 并执行main方法 kotlinc-jvm Main.kt && kotlin com.MainKt // (2.1)打包成jar 会自动处理包结构，并查找main函数配置主类，但没包含kotlin运行时 kotlinc -d main.jar ./src/ // 运行时需将Kotlin库包含进来, 如 java -cp kotlin-stdlib.jar kotlin -cp main.jar:$KOTLIN_HOME/libexec/lib/kotlin-stdlib.jar com.MainKt // (2.2)打包jar并将kotlin运行时打进jar包 kotlinc -d main.jar --include-runtime ./src/ // 即可按jar包执行, 如 java -jar main.jar kotlin main.jar // (3)Kotlin也可以按脚本方式执行 kotlin main.kts [args] // (4)不传参数直接进入REPL环境；使用`kotlin`无参命令可进入Read-Eval-Print-Loop交互式编程环境，快速运行 kotlin >>> import java.util.Date >>> Date() 其中, 运行main.kts依赖org.jetbrains.kotlin:kotlin-script-runtime:+ import java.io.File // kotlin main.kts -d ~/Downloads val path = if (args.contains(\"-d\")) args[1 + args.indexOf(\"-d\")] else \".\" File(path).listFiles { _ -> true }?.forEach { println(it) } 1.2 部署运行 Gradle构建JVM应用 执行: ./gradlew assemble后会得到Jar产物 // build.gradle buildscript { repositories { mavenCentral() } dependencies { // 负责Kotlin工程构建 classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.72' } } plugins { id 'java' // 项目中支持使用Java id 'org.jetbrains.kotlin.jvm' version '1.3.72' // 支持使用kotlin(JVM) } // 源码兼容JDK版本 sourceCompatibility = 1.8 repositories { // 组件依赖地址 https://repo.maven.apache.org/maven2/ mavenCentral() } dependencies { // 依赖 Kotlin JVM执行环境 implementation 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.72' } compileKotlin { // kotlin编译的字节码目标版本 kotlinOptions.jvmTarget = \"$sourceCompatibility\" } Web RESTFul # 社区版IDEA不支持直接创建Gradle的Spring项目，可从Spring官网下载 # https://spring.io/guides/tutorials/spring-boot-kotlin/ curl https://start.spring.io/starter.zip -d language=kotlin -d dependencies=web,mustache,jpa,h2,devtools -d packageName=com.chavin.demo -d name=Demo -d type=gradle-project -o demo.zip 解压后打开，根路径build.gralde.kts如下，构建部署task: ./gradlew bootRun // build.gradle.kts gradle 7.4.1 import org.jetbrains.kotlin.gradle.tasks.KotlinCompile plugins { // spring boot id('org.springframework.boot') version '2.7.0' // spring 包管理 id('io.spring.dependency-management') version '1.0.11.RELEASE' // kotlin-jvm kotlin('jvm') version '1.6.21' // kotlin plugin spring kotlin('plugin.spring') version '1.6.21' // kotlin plugin jpa kotlin('plugin.jpa') version '1.6.21' } // 源码兼容JDK版本 java.sourceCompatibility = JavaVersion.VERSION_18 tasks.withType { kotlinOptions { freeCompilerArgs = listOf('-Xjsr305=strict') jvmTarget = '18' } } repositories { // 组件依赖地址 https://repo.maven.apache.org/maven2/ mavenCentral() } dependencies { implementation('org.springframework.boot:spring-boot-starter-data-jpa') implementation('org.springframework.boot:spring-boot-starter-mustache') implementation('org.springframework.boot:spring-boot-starter-web') implementation('com.fasterxml.jackson.module:jackson-module-kotlin') implementation('org.jetbrains.kotlin:kotlin-reflect') implementation('org.jetbrains.kotlin:kotlin-stdlib-jdk8') developmentOnly('org.springframework.boot:spring-boot-devtools') runtimeOnly('com.h2database:h2') testImplementation('org.springframework.boot:spring-boot-starter-test') } JavaScript 编译后的js需依赖kotlin.js，通过kotlinc-js编译 // MyApp package com.chavin.js fun say(){ println(\"Hello world\") } (function(){ // 用 文件名.包名.方法名 引用 MyApp.com.chavin.js.say() })(); Kotlin Native Koltin Native利用LLVM来生成本地机器码，同时支持与C互操作。 LLVM Low Level Virtual Machine是开源跨平台的编译器基础设施；LLVM本身并不是编译器，LLVM架构提供了完整编译系统的中间层，包括： Fronted: 接受源码输入，负责词法分析、语法分析、语义分析(AST)、生成IR(RISC汇编语言)。 Optimizer: 针对IR，基于抽象语法树(AST)做进一步优化。 Backend: 由于后端生成可执行的机器码。 注： LLVM前端支持的语言：C、C++、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala、C#等 LLVM后端支持指令集架构：x86、x86-64、ARM、MIPS、PowerPC以及RISC-V等 命令行： # konan工具可在 https://github.com/JetBrains/kotlin/releases ,执行后生成 main.kexe kotlinc-native main.kt -o main Gradle： 在IDEA创建 Kotlin Multiplatform - Native Application 项目 // build.gradle.kts // ./gradlew nativeBinaries 生成 .kexe 可执行文件 plugins { kotlin(\"multiplatform\") version \"1.7.0\" } group = \"com.chavin\" version = \"1.0-SNAPSHOT\" repositories { mavenCentral() } kotlin { val hostOs = System.getProperty(\"os.name\") val isMingwX64 = hostOs.startsWith(\"Windows\") val nativeTarget = when { hostOs == \"Mac OS X\" -> macosX64(\"native\") hostOs == \"Linux\" -> linuxX64(\"native\") isMingwX64 -> mingwX64(\"native\") else -> throw GradleException(\"Host OS is not supported in Kotlin/Native.\") } nativeTarget.apply { binaries { executable { entryPoint = \"main\" } } } sourceSets { val nativeMain by getting val nativeTest by getting } } "},"chapter2/2.基础语法.html":{"url":"chapter2/2.基础语法.html","title":"2. 基础语法","keywords":"","body":"2. 基础语法 2.1 数据类型 Kotlin是强类型的(数值在运行时无隐式拓宽转换)、静态类型(类型检查发生在编译期)、支持类型推导的(当能推导出类型时可省略类型声明)语言。 它没有基本类型(但部分类型会优化为JVM的基本类型)，所有类型都是继承自Any?的引用类型: val b: Byte = 0b0010_1000; // 1B val s: Short = 0 // 2B val i = 1_000 // 4B,数值变量默认推断Int,如果超出范围才推断为Long val j = 0L // 8B // Kotlin 1.3引入无符号数值 val ub: UByte = 0xFF_FFU; val us: UShort = 0U val ui: UInt = 0U val uj: ULong = 0UL val f: Float = 0.0F // 4B,24位有效比特数（6~7位有效数字） val d: Double = 0.0 // 8B,53位有效比特数（15~16位有效数字）,浮点默认推断Double val c: Char = 'A' // 2B val z: Boolean = true // 1B 类型检测与转换 Kotlin使用is、!is来判断实例类型，使用as、as?用来显示转换类型。 fun main(args: Array) { val s = args.getOrElse(0) { \"unknown file\" } val ss: CharSequence? = if (s is CharSequence) { // is 检测后会自动转换 s.subSequence(0, s.length).toString() } else null // 即当 s !is CharSequence // as? 显式转换失败后会得到null println((ss as? String)?.plus(\" exec over!\")) var res: Boolean res = (s == ss) // 相当于Java的equals()方法调用,且有NPE保护 res = (s === ss) // 相当于Java的 == , 仅比较对象在的内存地址 } 可空类型 Kotlin把可空性作为类型系统的一部分，这样能在编译阶段发现可能的错误以减少运行时NPE的可能性。 注: Kotlin中 null === null 、null is Nothing?, 空类型断言通过Intrinsics工具类处理，安全调用会被翻译为三元运算符。 Kotlin提供 Unit表示表达式值没无其他用途的(Java中void) Nothing::class为java.lang.Void表示表达式结果不能获取的,Nothing?只能赋为null // Java中不安全Case: Integer ni = null; int i = ni; 编译通过但运行报错 val ni: Int? = null // 可空类型 val res: Long? = ni?.toLong() ?: -1L // 安全调用 ?. println(res!!.toString()) // 非空断言 !! fun format(num: Double): String = if (num.isNaN()) // Double/Float.NaN=-(0.0/0.0) 是唯一和自身不相等的浮点值 throw RuntimeException(\"not a num\") else num.toString() // 若方法声明为Nothing，则意味着调用后将得不到返回,如exitProcess() public inline fun exitProcess(status: Int): Nothing { System.exit(status) throw RuntimeException(\"System.exit returned normally, while it was supposed to halt JVM.\") } 数组Array 数组用Array表示(也有无装箱开销的TypeArray如IntArray)，它的get/set函数映射到[]操作，并有size属性，以及迭代器获取iterator()函数。 注: 与Java不同,Kotlin中数组是不型变的，即Array不是Array的子类型 // 自动升级为 [kotlin.Any; val arr = arrayOf(1, 2, \"3\", false, null, object : Any() { override fun toString(): String { return \"test\" } }) // 指定类型，元素都填充null（这种非空类型容易导致NPE） val sArr = arrayOfNulls(10) // 使用构造器+初始化函数创建 val iArr = Array(10) { i -> return@Array \"\" + (i * i) } // 无装箱开销的原生类型 val dArr: DoubleArray = doubleArrayOf(1.0, 2.0) println(arr.contentDeepToString()) println(sArr.contentToString()) for(i in iArr) println(i) // 用迭代器遍历 区间 区间是为可比较类型定义的(整型类型有优化实现)，表达式由..函数和 in 和 !in 构成。 val x = -1 // 区间 [1, 5] if (x !in 1..5) println(x) // [0,10]: 0 2 4 6 8 10 for (i in 0..10 step 2) print(\"$i \") // [0,10): 0 2 4 6 8 for (i in 0 until 10 step 2) print(\"$i \") // 10 7 4 1 for (i in 10 downTo 0 step 3) print(\"$i \") // 数组下标是 IntRange 类型 for (i in arr.indices) println(arr[i]) 字符串String 字符串用String表示，和Java一样是不可变的、支持串连接s = s + any(表达式首运算数为串时默认执行串连接)。另外： 支持下标访问s[i] 和 迭代器遍历 支持字符串模板，即在串中解析执行表达式\"\\$ expression result is ${expression}\" 支持原始字符长串(使用三个引号包裹，可以包含换行符，内部不支持转义，但仍支持串模板) val car = \"BMW\" val price = 100000000.00 // 其中trimIndent()对齐切割掉最小空格数，trimMargin()去除前导符前的空格 val res = \"\"\" > The price of $car is \\${'$'}${price} > emmm, I'll buy one. \"\"\".trimIndent().trimMargin(\"> \") print(res) // The price of BMW is \\$1.0E8 // emmm, I'll buy one. 2.2 常量变量 变量通过var(初始化后能重新赋值)或val(初始化后不可修改)定义，支持自动推导数据类型。 fun f(s:String?) { // 空引用包装保证相等性不保证同一性(指Integer对象池) val boxedX: Int? = 0x7F + 1 val boxedY: Int? = 0x7F + 1 println(boxedX == boxedY) // true println(boxedX === boxedY) // [-128, 127]外false var res:Int? // (1)安全调用, 若s为null, res=null res = s?.length // (2)非空断言, 若s为null抛出NPE res = s!!.length // (3)空时条件, 若s为null, res = -1 res = s?.length ?: -1 } 2.3 语句结构 Kotlin是面向表达式的语言，if-else和when既是控制语句也是表达式，而语句可以省略行尾分号; 分支结构 If-else取代了三目运算符，返回对应分支语句块中最后的表达式值。 When表达式，支持带参方式使用(增强版Switch)与无参方式使用。 val res:String = if (arg in 0 downTo -100 step 1) { println(\"negative\") \"negative\" // 语句块中最后一条语句值即为分支值 } else if (arg in 0..100) { \"positive\" } else { \"zero\" } // 无参分支链，通过布尔表达式匹配 when { null == s -> { } s.isEmpty() -> { } s.length > 9 -> { s = s.substring(0, 9) } else -> { } } // 有参结构，比对表达式和参数是否相等，或用于is、in表达式中 val res = when (val x: Any = Integer.parseInt(\"12\")) {// 支持在条件表达式处使用声明变量 0 -> \"zero\" 1, 2 -> \"a\" Integer.parseInt(\"3\") -> \"b\" is String -> \"string\" in 4..10 -> \"c\" else -> \"other\" } 循环结构 For循环用于可迭代类型(Iterable子类或拓展函数方式提供Iterator)，当对区间或数组遍历时会被优化而避免迭代器开销。 While、Do-While循环语法同Java for (item: Int in items) // 遍历迭代器对象 for (i in 1..9) // 遍历区间 [1, 9] for (i in 1 until 9) // 遍历区间 [1, 9) for (i in 9 downTo 1 step 2) // 或 for(i in 0 until 100 step 2) // 基于索引遍历 val arr = arrayOf(1, 2, 3) for (i in arr.indices) println(arr[i]) // 或 for((i,v) in arr.withIndex){} while (i 返回与跳转 return: 从最内层的函数或匿名函数(而不包含Lambda)返回。 break/continue: 跳过/终止最内层的循环。 注：返回和跳转语句都是表达式，其值为Noting类型。 标签 Kotlin中任何表达式都可以用标签标记label@,跳转和返回语句支持添加标签: break@label/continue@label 跳转到标签标记循环位置，执行终止或跳过动作 return@label 返回标签指定的函数或Lambda表达式(Lambda表达式具备隐式标签) fun foo() { // Output: 1 * 1 = 1、3 * 1 = 3、3 * 2 = 6、3 * 3 = 9 outer@ for (i in 0..3) { inner@ for (j in 0 until 4) { if (i * j == 0) continue@inner if (i * j == 4) continue@outer if (i * j == 6) break@outer println(\"$i * $j = ${i * j}\") } } val res = run label@{ listOf(1, 2, 3).forEach { // 默认的return会直接退出foo函数，添加标签限制的return可以从lambda表达式返回 if (2 == it) return@forEach // 带标签限制的return语句支持返回值 if (3 == it) return@label it println(\"forEach:$it\") } println(\"in label\") } println(\"after label $res\") } 2.4 包结构 包声明 文件添加声明包package com后,其的顶层函数、字段和类都被分在该包内,如com.test.f()。 包的结构与源码文件系统结构可以不匹配(编译器会自动处理)，未声明的属于无名的默认包。 注: 如果顶层声明是private则其仅在该文件内可见不可其他地方导入使用。 库导入 可导入类、顶层函数、顶层字段、Object中的函数和属性(Java的静态成员)、枚举常量。 库导入import com.util.MyClass，支持具名导入import com.util.f as myFunc // Kotlin源文件不一定要匹配包的文件路径 package com.test // 导入类 import java.util.ArrayList // 导入静态方法 并赋予别名 import java.util.Collections.binarySearch as bSearch fun main(args: Array) { val list = ArrayList(10) for (i in 0 until 10) list.add(i) val index = bSearch(list, 5) } 2.5 异常捕获 Kotlin不强制要求捕获异常(即Kotlin中无受检异常概念)，但若运行时未捕获的异常仍会导致进程Crash。 throw表达式的值类型为Nothing "},"chapter3/3.面向对象.html":{"url":"chapter3/3.面向对象.html","title":"3. 面向对象","keywords":"","body":"3. 面向对象 软件开发的发展链路: 面向过程：自顶向下、逐步求精（易读写、易调试、易维护、易保证与验证正确性） 面向对象：复用性、灵活性（适应需求变化） 面向组件：从重用零件到重用部件 面向服务：将系统功能化，每个功能提供一种服务 3.1 类 在面向对象的命令式(imperative)编程里,提倡针对具体问题建立专门的数据结构,相关操作以方法的形式附加到数据结构上,自顶向下地构建虚拟世界: 1个思想：一切皆对象。 4个特性：抽象、封装、继承、多态。 7个原则：SOLID' + 合成复用(组合优于继承)。 23种模式：GOF。 类用class声明，类中可以包含 构造函数、初始化块、成员字段、成员函数、对象声明/嵌套类/内部类。 可见性修饰： public: 公开访问，Kotlin类成员默认public。 internal: 模块内可见(Java9引入模块概念，通常指一个项目Module/Jar)。 protected: 派生类可见；成员覆盖后默认还是protected。 private: 顶层声明仅文件内可见，类中声明仅本类中可见。 // 类默认是`public final`不可继承的，如需复写父类要添加open修饰 // 如主构造器无注解和可见性修饰,可省略constructor；主构造的参数可以在字段初始化和初始化块中用 // 默认会生成public的无参主构造，主构造参数添加val/var修饰使对应参数成为成员字段 class Foo protected constructor(val arg: String) : Any() { // 非抽象的属性必须初始化,默认public var value: Int = 0 get() { println(\"getValue...\") return field } set(value) { println(\"setValue\") field = value } // 使用lateinit修饰非空可变字段以延迟初始化 lateinit var value1: String init { // 主构造函数不含代码，初始化块会最终合成主构造函数体 } // 可包含若干次构造函数，并需调用主构造函数 constructor(i: Int) : this(\"\") { } // 函数默认是public final的 fun doSth(): Unit { if (this::value1.isInitialized) { value1 = \"\" } // 指定父类方法调用，使用于基类和接口中方法名冲突时(覆盖冲突) super.hashCode() } } // 对顶层字段或object的成员(不能自定义getter)添加`const`修饰 // 使之成为编译器常量(public static final,只能用基本类型值或String初始化) const val CONST: String = \"this is a constant\" // 非基本类型的顶层属性，可以用lateinit修饰 lateinit var x: String fun main(args: Array) { // Kotlin没有new关键字，调用构造函数即创建新对象 val foo = Foo() // 非基本类型的局部变量，可以用lateinit修饰 lateinit var y: List if (!::x.isInitialized) { x = \"\" } } 3.2 特殊类 嵌套类 普通嵌套类: 相当于Java中静态内部类,不持有外部类隐式引用的。 内部类: inner修饰的内部类会带有一个外部类对象的引用this@Outer。 匿名内部类: 通常伴随着匿名对象的创建。 class Outer(val value: Int) { class Nested { /* 嵌套类不能访问外部类成员 */ } inner class Inner(val key: Int = value) { /* 可以访问外部类成员 */ } init { val obj = object : Runnable { // 可使用Lambda: obj={ /* do sth */ } override fun run() { /* 可以访问外部类成员 */ } } } } 数据类 数据类只能是final的，可以拓展自其他类，但不能是abstract/open/sealed/inner修饰的。 主构造器至少有一个标记为val/var的参数，可以使用参数默认值。 根据属性自动生成： equals/hashCode() toString(), 形如User(name=Nancy, age=10) copy() componentN() 按声明顺序生成component1(),component2()...用于解构 final data class User(val name: String, val age: Int) fun main(args: Array) { val user1 = User(\"Allen\", 12) val (name, age) = user1 // 解构 val user2 = user1.copy(\"Bob\") // 处理拷贝 println(user1.copy() == user1) // true:自动生成hashCode()/equals()对比内容 } 元组 Kotlin为同类型元素的元组添加了toList()拓展函数: 二元组: data class Pair 三元组: data class Triple Java只保存数据的领域实体类 POJO：Plain Ordinary / Pure Old Java Object，只具有一些getter/setter的类对象。 DTO：Data Transfer Object，用于展示层与服务层之间的数据传输对象。 VO：ViewObject或ValueObject。 PO：Persisent Object，持久层使用的持久化对象。 BO：Business Object，业务层使用的描述事务的实体对象，如BBS的文章、评论、用户。 DO：Domain Object，领域对象，从现实世界抽象出的业务实体。 枚举类 枚举用enum class声明: 枚举类是final的不可派生, 枚举常量是单例对象(多个用逗号分隔)。 // 声明枚举类；枚举常量是一个对象 enum class RGB(val argb: Int) { RED(0x01FF0000) { // 枚举常量可以声明自己的匿名类 override val alpha: Int get() = 0 }, GREEN(0x0000FF00), BLUE(0x000000FF); open val alpha: Int = argb shr 48 } // 使用 enumValues()列出所有枚举值 println(enumValues().joinToString { \"${it.name}:${it.ordinal}=${it.argb}\" }) val red = RGB.values()[0] var res = RGB.valueOf(\"Red\") // 从字符串构建实例，找不到就抛异常 // kotlin的枚举类型定义 public abstract class Enum>(name: String, ordinal: Int) : Comparable { public final val name: String // 枚举对象名 public final val ordinal: Int // 下标位置，从0开始 } 密封类 密封和枚举都是为了限制类的继承结构(限制实例或派生类数量)，sealed不能修饰抽象类和接口。 enum类：枚举类是final的，枚举常量只存在一个实例。 sealed类：密封类的子类是final的，但子类可以有包含状态的多个实例。 sealed class Expression class Num(var n: Double) : Expression() class Sum(var a: Expression, var b: Expression) : Expression() class Sub(var a: Expression, var b: Expression) : Expression() fun eval(e: Expression): Double = when (e) { // when无需添加else is Num -> e.n is Sub -> eval(e.a) - eval(e.b) is Sum -> eval(e.a) + eval(e.b) } 注解类 Kotlin的注解和Java注解完全兼容： @Target(AnnotationTarget.CLASS) // 修饰对象 @Retention(AnnotationRetention.RUNTIME) // 注解保存策略 @Repeatable // 可重复修饰 @MustBeDocumented // 支持出现在自动生成的API文档中 // 声明注解类 annotation class SPI(val insType: InsType = InsType.STANDARD) { enum class InsType { SINGLE, STANDARD } } @SPI(SPI.InsType.SINGLE) // 使用注解 interface PrintService { fun print() } 3.3 继承 Koltin的类默认是final的，需显式声明为open或abstract才可被继承，且只支持单继承类，但可以实现多个接口。 注: 基类构造函数或初始化块中不能使用open修饰的字段，因为被覆盖的字段可能初始化还没完成。 继承耦合度高，应优先考虑用组合替换继承。 interface ISpeaker { // 接口可以声明抽象属性，抽象属性可不用初始化 val name: String // 接口的属性也可以提供访问器 var owner: String get() = \"\" set(value) {} // 接口方法默认是抽象的，但可以有默认实现 fun introduce() = println(\"Hi everyone,my name is $name\") } interface IHuman { fun introduce() = println(\"Are you OK?\") } abstract class AbsPerson : IHuman { // 抽象函数是open的 abstract fun work() // abstract或open类中的非抽象函数默认是final的，若要复写需显式声明open open fun rest() = println(\"Resting\") } // 只能基础一个父类，可以实现多个接口 class Programmer : AbsPerson, ISpeaker { // 基类为的val字段子类可声明为var，相当于加多一个set方法。反之则不行 override var name: String = \"\" // 若子类无主构造函数，必须在次构造函数中用super()形式调用父类构造函数 constructor(name: String) : super() { this.name = name } // 覆盖冲突时候，使用super<>语法调指定父类方法 override fun introduce() { super.introduce() super.introduce() println(\"I'm fine, thks\") } override fun work() { println(\"Writing code\") this.rest() } // override函数默认是open的，可加final修饰禁止重写 final override fun rest() { println(\"Close eyes\") super.rest() } } 接口与抽象类 接口：定义了一些行为规约(接口间可通过继承拓展)；Kotlin的接口可以包含属性声明，也可以包含方法默认实现。 抽象类：含有抽象函数的类(需用abstract修饰)为抽象类。 概念上： 接口是对动作的抽象，定义了行为特性的规约。 类是对一类事物的抽象，包含了事物属性与行为。 语法上： 接口不能保存状态，一个类可以实现多个接口。 抽象类可以有非抽象属性和方法，一个类只能继承一个父类。 设计上： 接口时辐射式设计，接口变更了所有实现类都需变更。 抽象类是模板式设计，抽象类新增方法子类可以不变更。 应用上： 接口的实现者和接口是has-a关系，耦合程度更低。 继承者和抽象类is-a关系，是强耦合的（优先应考虑组合：实现多接口组合、成员依赖）。 3.4 拓展 拓展函数和拓展属性用于向类添加新特性而无需继承或使用装饰器模式，拓展通常在顶层包中定义。 注: 若成员函数签名和扩展函数一致时，会优先使用成员函数。 扩展是一种静态行为(父类子类有同名拓展时，父类对象调用不会执行子类的扩展)，也不会影响被扩展类的字节码。 扩展的接受者是静态绑定的，但拓展的分发者可以动态绑定。 package com.chavin.kt // 拓展函数 fun MutableList.swap(i: Int, j: Int): MutableList { val t = this[i] this[i] = this[j] this[j] = t return this } // 拓展属性，只能扩展val属性 val CharSequence.initial get():Char? { if (this.isEmpty()) return null return this[0].uppercaseChar() } // 扩展接受者：静态绑定 class Util open class Base { // Base是扩展分发者：动态绑定 open fun Util.u() { println(\"Base.u()\") } fun call(util: Util) { util.u() } } class Child : Base() { override fun Util.u() { println(\"Child.u()\") } } fun main() { // 输出: Child.u() val p: Base = Child() p.call(Util()) } 3.5 Object Kotlin中没有静态属性和方法，但支持在类加载时构建该类的单例伴生对象。 // (1)全局单例Object：Util无法创建新实例，是饿汉式单例,在静态块中创建对象 object Util { @JvmStatic // 告诉编译器生成静态方法，否则默认生成final的成员方法 fun test() {} } // (2)嵌套在普通类中的object, 相当于Java中饿汉模式单例的静态内部类 class Activity { @JvmField // 告诉编译器直接暴露字段name而非getName()方法 val name: String? = null object Const { val addr = \"xxx\" } } val addr = Activity.Const.addr // 使用嵌套Object // (3)匿名Object：匿名对象只能方法局部作用域、类中private作用域中使用；其他位置同Any无法访问其成员 // 和Java不同的是，object表达式中的代码可以访问外部作用域的非final变量 // (4)伴生对象：一个类只能有一个伴生对象(静态字段)，默认引用名是Companion，可以自定义对象名 class MyClass { companion object Companion { private val point = object { var x = 0; var y = 0; } val p = point } } val x: Any = MyClass.p // 使用时，可省略Companion 对象表达式 对象表达式可以就地创建一个匿名类的匿名对象。 open class Abs(val name: String) interface ICall { fun onCall() } fun main() { var count: Int = 0 // 对象表达式中可以直接访问外部变量 val obj = object : Abs(\"test\"), ICall { override fun onCall() { println(\"$name onCall ${++count}\") } } // 没有显式继承或实现，则基类为Any val local = object { val url: String = \"\" } // 匿名对象在 局部左右域和私有作用域中 可用，否则会退化为基类型无法范围属性和函数 println(local.url) } 对象声明 对象声明可以方便地写出单例模式（单例对象在该类被加载时实例化）。 注: 对象声明并不是动态绑定的，即对象声明在内部时不能访问到外部类对象的成员方法和成员字段 class X { val name: String? = null object XManager {} // 声明在类内部的对象，无法访问外部类的成员 X.name } fun main() { val xObj = X() // 获取单例对象, error: xObj.XManager val mgr = X.XManager } 伴生对象 类内部的对象声明用companion标记后，可以直接通过外部类访问到该对象的内部元素(如同外部类的静态成员)。 注: 一个类最多只有一个伴生对象，该对象在外部类加载时初始化。 interface IFactory { fun create(): T } class Manager { var name: String = \"name\" // 伴生对象省略对象名后，对象名默认为 Companion companion object : IFactory { override fun create() = Manager() } } 3.6 委托 在委托模式(亦代理模式)中，有两个对象参与请求处理：接受请求的对象将请求委托给代理对象处理： 代理是一种基础处理，状态模式、策略模式、访问者模式中都有代理操作。 代理用聚合来代替继承，复用并降低耦合，还可以模拟mixin混合类型。 Kotlin在语言层面通过by关键字对代理做了支持。 类的委托 类中的方法被调用时，会转发给另一个对象(该对象类型实现了同样的接口) interface ISubject { fun doSth() fun doOther() } class RealSubject() : ISubject { override fun doSth() = println(\"real do sth\") override fun doOther() = println(\"real do other\") } // 对ISubject的方法默认转发给sub对象 class WrapperSubject(val sub: ISubject) : ISubject by sub { override fun doOther() { println(\"wrapper do other\") sub.doOther() // 手动转发请求 } } 属性委托 类中的属性在声明时需要赋值，属性委托赋予属性富有变化的活力： 懒加载fun lazy()：属性值在首次访问属性时执行Lambda计算，以后直接返回结果；局部变量也支持惰性初始化。 延迟初始化Delegates.notNull：适用于无法在初始化阶段确定值的非空属性，若访问时仍未初始化会抛异常，类似lateinit。 可观察属性Delegates.observable：监听器会收到有关属性变更的通知。 可否决属性Delegates.vetoable：当收到属性变更通知时，可选择接受或否决变更。 属性Map管理 和 自定义属性委托：属性不在类中直接定义，而是托付给一个代理对象统一管理。 // (1)懒加载属性委托 internal class User { // 默认是 LazyThreadSafetyMode.SYNCHRONIZED：保证仅一个线程执行一次初始化 val name by lazy { String(\"Hello\".toByteArray()) + \"World\" } // LazyThreadSafetyMode.PUBLICATION：可多个线程执行初始化，但仅使用最先返回的值 val age by lazy(LazyThreadSafetyMode.PUBLICATION) { Math.random() } // 对多线程不做干涉，仅单线程初始化场景下结果可预知（性能最好） val sex by lazy { 1 == Math.random().toInt() and 1 } } // (2)非空属性，延迟初始化 class User { var s: String by Delegates.notNull() lateinit var t: String } // (3)可观察属性 class User { // implementation \"org.jetbrains.kotlin:kotlin-reflect:+\" val addr by Delegates.observable(\"\") { p: KProperty, old: String, new: String -> println(\"${p.name} changed from $old to $new\") } } // (4)可否决属性 class User { val addr by Delegates.vetoable(\"\") { p: KProperty, old: String, new: String -> return@vetoable new.isBlank() // 不接受空地址 } } // (5)属性委托给Map class User(info: MutableMap) { val name: String? by info val age: Int? by info val sex: Boolean? by info } val u = User(mutableMapOf( \"name\" to \"Allen\", \"sex\" to false ).withDefault { null }) // (6)自定义属性委托 class User(var firstName: String, var lastName: String) { val name: String by Delegate() // Kotlin会生成辅助属性 name$delegate // 代理类需 getValue/setValue() 操作符函数, 参见 ReadWriteProperty private class Delegate : ReadOnlyProperty { override operator fun getValue(thiRef: User, property: KProperty): String { return \"${thiRef.firstName}·${thiRef.lastName}\" } } } "},"chapter4/4.泛型.html":{"url":"chapter4/4.泛型.html","title":"4. 泛型","keywords":"","body":"4. 泛型 概念类似数学中的泛函数，泛型类是以类型为参数的类型：编译期约束运行时擦除。旨在类型安全的代码复用： 类型参数：声明类/函数时对其内部数据类型的参数化，侧重于声明处的代码复用 类型通配符：使用的对象的类型的通用化(但又支持编译期检查)，侧重于实例使用处的代码复用 注：类型参数是占位符，当泛型类被使用时它将被擦除(.class文件中实际用的是Object/显式指明的上限类型)。 // 默认的上限时Any?，若有多个上限可使用where子语句 class MyClass(var t: T) where T : CharSequence, T : Comparable { } // 泛型函数 上限为Number fun MyClass.update(t: T) { this.value = t } 4.1 Java型变支持 Java的泛型是不型变的，但支持在使用侧借助类型通配符完成协变和逆变。 类型通配符 ? extends T 指定类型参数的上限，该类型(?)必须是类型T或者它的子类型 ? super T 指定类型参数的下限，该类型(?)必须是类型T或者它的父类型 ? 无界通配符，代表任意未知类型 以 Cat -|> Animal 表示class Cat: Animal、ShepherdDog -|> Dog -|> Animal： 注： List和List不存在父子类型关系，即泛型是不型变的。 List只能Get不能Put，因为不知道容器内元素的具体类型 List只能Put不能Get，因为Get出的元素无法引用(也不知道具体类型) List能Get出Object元素，只能Put进null 协变 Convariant：若 C -|> F 时有 f(C) -|> f(F) 则f叫做协变，其中f(F)形如List。 Java的数组是协变的，即Number[] arr = new Integer[10]; 但这样的协变并不安全： Object[] os = new Integer[10]; os[0] = \"\"; // error: ArrayStoreException Java通过? extends上限通配符来实现协变： Integer -|> ? extends Number 且有 List -|> List List nList = new ArrayList(Arrays.asList(1, 2, 3)); Number n = nList.get(0); // 可以取出Number nList.add(null); // 只能写入null // nList.add(4); // error 逆协变 Contravariant：若 C -|> F 时有 f(F) -|> f(C) 则f叫做逆变, 其中f(C)指List Java通过? super下限通配符来实现逆变： ? super Integer -|> Number 且有 List -|> List List nList = new ArrayList(Arrays.asList(1, 2, 3)); Object obj = nList.get(0); // 只能取Object nList.add(4); // 可以写入Integer 注： 若协变和逆变关系都不成立，则叫做不型变。 PECS(producer-extends, consumer-super)即Get and Put Principle，用法参见Collections.copy() // Collections public static void copy(List dest, List src) { int srcSize = src.size(); if (srcSize di = dest.listIterator(); // in T ListIterator si = src.listIterator(); // out T for (int i = 0; i 4.2 Kotlin型变支持 使用处型变 Kotlin舍弃了类型通配符，在使用侧型变是用out/in修饰带来的类型投影(通过移除类的某些方法来限制使用)完成： 只读(类似? extends T)：Array只保证取出数据的类型安全，即只能调返回T的方法，集合对象是生产者 只写(类似? super T)：Array只保证写入数据的类型安全，即只能调传入T的方法，集合对象是消费者 原生无界通配(对应?)：Array只能取出Any?，只能写入Nothing public class Array {} fun copy(dist: Array, src: Array) { // in T: 对于dist只能调用传入T的方法，投影移除了返回T的方法 // out T: 对于src只能调用返回T的方法，投影移除了传入T的方法 for (i in src.indices) { dist[i] = src[i].toInt() } } fun main(args: Array) { val nArr: Array = arrayOf(1) val iArr: Array = arrayOf(1) copy(nArr, iArr) copy(iArr, nArr) } 声明处型变 对于类型中只存在某一类方法（只返回T，或只传入T），可以在泛型声明时添加协变修饰，此后该泛型类为支持型变的类型。 只有返回T的方法（生产者，用out T），支持协变是类型安全的 只有传入T的方法（消费者，用in T），支持逆变是类型安全的 // 声明支持协变 interface List : Collection {} // 声明支持逆变 interface Comparable {} val list: List = listOf() // 协变 val numCmp = object : Comparable { override fun compareTo(other: Number): Int { return 0 } } val cmp: Comparable = numCmp // 逆变 类型投影 在不感知类型参数的情况下，可使用星投影语法声明一个泛型类的类型投影：改投影类型可以接受目标泛型类的任意实例（类似Java），但读写时有限制： 对于泛型Foo，投影类型Foo 等价于 Foo：当T未知时，可以安全地从Foo 读取TUpper值。 对于泛型Foo，投影类型Foo等价于Foo：当T未知时，不能安全地向Foo 写入任何值。 对于泛型Foo: 读取值时投影类型Foo等价于Foo。 写入值时投影类型Foo等价于Foo。 注： 如果泛型类有多个类型参数，每个类型参数都可以单独投影； 对比Kotlin类型投影List和Java无界限通配符List： 读取：Kotlin星投影语法可取出类型上限，Java无界通配符只能取出Object。 写入：Kotlin星投影语法不能写入(in Nothing)，Java无界通配符只能写入null。 class Test( private var t: T, val u: U, var v: V ) { fun setT(arg: T) { t = arg } } fun main(args: Array) { val t: Test = Test(null, \"\", 0) // t.setT(Nothing); // Test val chs: CharSequence = t.u // Test val obj: Number = t.v // Test Test // t.v = 0 // ERROR: Setter for 'v' is removed by type projection } "},"chapter5/5.运算符重载.html":{"url":"chapter5/5.运算符重载.html","title":"5. 运算符重载","keywords":"","body":"5. 运算符重载 5.1 运算符和优先级 后缀Postfix: ++、--、.、?.、? 前缀Prefix: -、+、++、--、!、标签定义@: RHS(right-hand side class type): :、as、as? 乘除Multiplicative: *、/、% 加减Additive: +、- 区间Range: .. 中缀函数Infix fun: 如infix fun Int.shl(x:Int):Int {} 当 1 shl 2等同1.shl(2) 左移：val res = 1 shl 2 右移: -4 shr 1 == -2 无符号右移: -2 ushr 1 == 2147483646 位运算: and or xor，取反是inv()方法 Elvis: ?: 同if(x!==null) x else 0 Named checks: in、!in、is、!is Comparison: 、>、、>= Equality: ==、!=、引用相等符仅判断引用是否相同===、!==，判空时会自动使用引用相等 Conjunction: && Disjunction: || Assignment: =、+=、-=、*=、/=、%= 注: 编译器针对基本类型的运算做了优化，不会额外增加函数调用的开销。 位与移位运算没有特殊字符，只能用中缀方式调用具名函数 5.2 运算符重载 重载操作符的函数需要用operator 修饰符标记，中缀操作符的函数使 用infix命名函数修饰。 一元操作符: +a: a.unaryPlus() -a: a.unaryMinus() !a: a.not() a++、++a: a.inc() 与C++不同，Kotlin会自动区分前后缀调用 a--、--a: a.dec() 二元操作符: a#b => a.func(b) 算术+ - * / % ..: plus() minus() times() div() rem/mod() rangeTo() 包含in !in: contains() 索引a[i]=a[j]: get() set() 调用a(b): a.invoke(b) 复合赋值: a.xxxAssign(b) 其中xxx为算术运算符函数 相等== !=: equals() 比较: a.compareTo(b) # 0 其中#为 = 注：在IDE中 CTRL/CMD + ML点击运算符可跳转函数定义。 例如，当编译器处理表达式+a时，它将执行以下步骤: 确定a的类型，令其为T。 为接收者T查找一个带有operator修饰符的无参函数unaryPlus()，即成员函数或扩展函数。 如果函数不存在或不明确，则导致编译错误。 如果函数存在且其返回类型为R，则表达式+a的值类型为R。 "},"chapter6/6.集合类.html":{"url":"chapter6/6.集合类.html","title":"6. 集合类","keywords":"","body":"6. 集合类 Kotlin的集合类分为可变集合类(Mutable)与不可变集合类(Immutable:只读、可序列化)。 主要有3种: list、set 和 map。特别的空集合对象是全局单例的。 6.1 List 创建与转换: listOf()、mutableListOf()、arrayListOf() toMutableList()、toList() 遍历: 迭代器 it = list.listIterator(); for(e in list) ForEach l.forEach(::println)、l.forEachIndexed {i,e-> println(\"$i->$e\")} 求和 list.sum() 、list.sumOf {e-> 2*e}后者求 sum(f(x)) 其中 f(x)=2*x 遍历累计 reduce() fold() foldRight() CURD: 增: add()、plus() 删: remove()、clear() 改: set方法list[0]=e 查: getOrNull()、elementAt() 排序: sorted() sortedDescending() reversed() sortedWith(cmp) sortedBy(f) 按条件取元素: 从左向右查找firstOrNull(predicate) 从右向左查找lastOrNull(predicate) 查找唯一满足条件的元素singleOrNull(predicate) 查询元素下标: indexOfFirst() 、indexOfLast() 统计判断: 是否所有元素都不满足 list.none(predicate) 是否存在一个元素满足 list.any(predicate) 是否所有元素都满足 list.all(predicate) 统计满足条件的元素数 list.count(predicate) 判断元素是否在列表中 list.contains(ele) 最值: min/max() minWith(cmp) minOf(f) minBy(f) 其中minBy(f)返回f(x)值最小时的x值 过滤: 取满足条件的一系列 take(N) takeWhile(predicate) takeLast(N) 去掉满足条件的取补 drop(N) dropLastWhile(predicate) 根据下标挑选 slice(idxs) 根据条件过滤 filterTo() 映射: 根据映射关系取新集 map() 、mapNotNull() 扁平化映射 flatMap() 分组: groupBy(keyGen, valGen) 压解: cL=aL.zip(bL) cL.unzip().also{ aL=it.first; bL=it.second} 拆分: partition(predicate) 依据满足与否分成2组 交集: aL.retainAll{ bL.contains(it) } // 只读、可写List创建与转换 val iList = listOf(1, 2, 3) val mList = mutableListOf(4, 5, 6) val list = listOf(1, 2, 3).toMutableList() val iL = mutableListOf(4, 5, 6).toList() // 取迭代器遍历 和 forEach遍历 val it = list.listIterator() iList.forEach(::println) // 遍历求值: sum reduce fold forEach var sum = list.sum() // 元素累加和 sum = list.sumOf { e -> 2 * e } // y=f(x)=2*x的累加和，即 2 * list.sum() sum = list.reduce { acc, e -> acc + e } // 从左向右累加，空集不抛异常用 reduceOrNull sum = list.reduceRight { e, acc -> acc + e } // 从右向左累加 var mul = list.fold(1) { acc: Int, e: Int -> acc * e } // 从左向右累乘 mul = list.foldRight(1) { e, acc -> acc * e } // 从右向左累乘 list.forEachIndexed { index, e -> println(\"list[$index]=$e\") } // 带索引遍历 // 增删改查: add/plus remove/clear set get list.add(7); list += 8 // list.plus(e) list += 9..20 // list.plus(otherList) list.remove(1) // return false: no ele==1 list.removeAt(4) list.clear() list[0] = -1 // set(i, e) // 根据下标返回元素 elementAt() 和 get() 类似 list.elementAt(0) // 越界抛出 IndexOutOfBoundsException list.elementAtOrNull(-1) // 越界返回 null list.elementAtOrElse(-1, Integer::valueOf) // 越界返回 def 值, 即下标值 // 排序: sorted sortedDescending reversed var sortedList = list.sortedDescending() // 排降序 sortedList = list.sortedWith(Int::compareTo) // 自定义比较器排序 sortedList = list.sortedBy { e -> e * e } // 比较 f(x)=x^2 对x排升序, f(x)=null时x排在最前 sortedList = list.reversed() // 列表倒序 // 取满足条件的首元素，NoSuchElementException var target: Int? = list.first { e -> e > 100 } target = list.firstOrNull() // 取满足条件的尾元素，NoSuchElementException target = list.last { e -> e > 100 } target = list.lastOrNull { e -> e > 100 } // 返回满足条件的唯一元素，没有或非唯一则抛异常 target = list.single { e -> e == -1 } target = list.singleOrNull() // 返回指定元素的下标，没有返回 -1 var idx = list.indexOf(1) idx = list.indexOfFirst { e -> e and 1 == 0 } idx = list.lastIndexOf(1) idx = list.indexOfLast { e -> e and 1 == 0 } // 统计判断: any all none count contains res = list.all { e -> e and 1 == 0 } // 是否所有元素都是偶数 res = list.any { e -> e and 1 == 0 } // 是否有元素是偶数 res = list.none { e -> e and 1 == 0 } // 是否没有元素是偶数 var cnt = list.count { e -> e and 1 == 0 } // 统计偶数个数 var res = listOf(1, 2, 3).contains(4) // 判断是否包含某元素 // 求最值: min max var minX = list.minWith(Comparable::compareTo) // 比较算法同list.min()，但空集会抛异常 var minY = list.minOf { e -> e * e } // y = f(x) = x^2，支持自定义f(x)比较器 minOfWith(cmp, slc) minX = list.minBy { e -> e * e } // 比较y=f(x)返回x，即求x令f(x)值最小 list.maxWithOrNull(Int::compareTo) list.maxOfWithOrNull(Int::compareTo) { e -> e * e } list.maxByOrNull { e -> e * e } // 过滤: take drop slice filter val topN = list.take(5) // 取出前N个 list.takeLast(n) list.takeWhile { e -> e and 1 == 0 } // 从前向后取，遇到不满足条件元素就停止 list.takeLastWhile() var bottom = list.drop(5) // 去掉前N个 list.dropLast(n) bottom = list.dropWhile { e -> e and 1 == 0 } // 从前向后丢弃直到遇到不满足条件元素 list.dropLastWhile() val evenEleList = list.slice(0..list.size step 2) // 获取偶数下标元素 val filtered = list.filterIsInstanceTo(mutableListOf()) list.filterTo(filtered) { e -> e and 1 == 0 } val notNullFilter = listOf(\"1\", null, \"2\").filterNotNull() // 去除结果中的Null元素 // 映射: map flatMap var mapList = list.map { e -> \"$e\" } // 做一次映射转换，得到新的List mapList = mapList.mapIndexedNotNull { i, e -> if (e.isBlank()) null else \"$i->$e\" } // 去掉映射过程中的null结果 list.mapNotNull { e -> listOf(e - 1, e) } // [1,2,3] -> [[0,1], [1,2], [2,3]] list.flatMap { e -> listOf(e - 1, e) } // [1,2,3] -> [0,1, 1,2, 2,3] 扁平化结果 // 分组: groupBy val groups = list.groupBy({ e -> e.hashCode() }, { e -> \"$e\" }) // 分组后得到 Map> val gCnt = list.groupingBy { e -> e % 5 }.eachCount() // 得到各组的统计数 Map // 压缩/解压、拆分: zip unzip partition var xList = listOf(1, 2, 3, 4) var yList = listOf(\"a\", \"b\", \"c\") val xy: List> = xList.zip(yList) // 压缩 eX to eY 构成新的List, len=min(lenA, lenB) xy.unzip().also { xList = it.first; yList = it.second } // 解压缩取新的List (1..10).toList().partition { e -> e and 1 == 0 }.also { //partition拆分List it.first.forEach(::println) // true: even list it.second.forEach(::println) // false: odd list } // 取集合交集 val aList = mutableListOf(1, 2, 3, 4, 5) val bList = mutableListOf(1, 3, 5, 7, 9) aList.retainAll { return@retainAll bList.contains(it) } aList.forEach(::println) 6.2 Set Set和List一样都继承自Collection，List中继承自Collection的函数同样适用于Set。 创建: 不可变集: setOf() LinkedHashSet: mutableSetOf() 、linkedSetOf() HashSet: hashSetOf() TreeSet: sortedSetOf() Set会自动去重: Iterable.toSet() 运算: 合并: plus() 即 set + set2/ele 移除: minus() 即 set - set2/ele val iSet = setOf(1, 2, 3, 4) val mSet = mutableSetOf(5, 6, 7) mSet += iSet + 9 - 4 6.3 Map Map没有继承Collection，仅对Java的Map做了一些拓展。 注: HashMap允许Null值Null键；LinkedHashMa的Entry保持着添加时的顺序 创建与转换: 不可变: mapOf() LinkedHashMap: mutableMapOf() 、linkedMapOf() HashMap: hashMapOf() TreeMap: sortedMapOf() 可写性转换: iMap.toMutableMap() 、map.toMap() Pair集合转Map: Iterable>.toMap() 遍历: 迭代器: for(entry in map.entries) Entry.component操作符: for((k,v) in map) 读取: 是否包含: map.contians(k) get方法: map[k] 不存在时返回Null map.getValue(k) 不存在时抛异常 带默认值: getOrDefault() getOrElse() getOrPut() 写入: set/put方法: map[k] = v put方法会额外返回当前k的历史值 plus方法: map + (k to v) minus方法: map - k 清理: map.remove(k) map.clear() 过滤：map.filter(predicate) 映射：修改键/值 修改键: map.mapKeys() 修改值: map.mapValues() val imap = mapOf(1 to \"a\", 2 to \"b\") val map = imap.toMutableMap() listOf(1 to 'A', 2 to 'B').toMap() // Pair集合转Map // 遍历 for (e in map.entries) { // map.entries 同 map.keys.zip(map.values) println(\"${e.toPair()}\") // Entry -> Pair } // Map.Entry支持操作符 component1()、component2()，即支持键值对遍历 for ((k, v) in map); // 判断是否包含 val isContain = map.contains(-1) // 获取 map[0] // map.get(k) 元素不存在返回null map.getValue(1) // 元素不存在抛出 NoSuchElementException map.getOrDefault(0, \"nil\") map.getOrElse(0) { \"nil\" } map.getOrPut(3) { \"c\" } // 添加 map[0] = \"0\" // map.set(k, v) 亦 map.put(k, v) val v = map.putIfAbsent(0, \"0\") // 元素不存在时put map += Pair(3, \"C\") // map.plus() 添加元素 // 移除 map -= 3 // map.minus() 移除元素 val lastVal = map.remove(-1) map.clear() // 清空Map // 过滤 var filtered = map.filter { it.value.isNotBlank() } filtered = map.filterValues { it.isNotBlank() } // 映射(修改key或value) var mapped = map.mapKeys { it.key * 2 } mapped = map.mapValues { \"${it.key}#${it.value}\" } "},"chapter7/7.面向函数.html":{"url":"chapter7/7.面向函数.html","title":"7. 面向函数","keywords":"","body":"7. 面向函数 在面向函数的函数式编程里,提倡在有限的几种关键数据结构(如list、set、map)上 ，运用函数的组合(支持高阶函数的特性)操作，自底向上地来构建虚拟世界。 FOP相关概念 函数是第一等公民：函数可以赋值给变量(称闭包对象或仿函数对象)，可以作为参数和返回值。 高阶函数：接收一个函数作为输入，或返回一个函数作为输出(即多阶映射)。 函数柯里化：fun curryAdd(x:Int): (Int)->Int = {y-> x+y}，调用ans = curryAdd(1)(2) 闭包：闭包就是一个代码块，可以被一个变量所引用(此时代码也就成了数据，典型应用如回调函数) 懒惰计算：表达式不是在绑定到变量时立即计算，而是在需要产生表达式值时。如map()、filter() 递归：递推 + 回归。 无副作用：即函数要保持独立，所有功能就是返回一个新的值，尤其不会修改外部变量。 注： 函数式编程(泛函编程)是一种编程范式(如何编程的方法论)，基于λ演算；相比指令式编程，更注重函数的计算(一切皆函数)，函数可以作为另一函数的输入与输出。 程序 = 匀称的数据结构 + 匀称的算法 OOP: 胖数据结构-瘦算法(FDS-TA) FOP: 瘦数据结构-瘦算法(TDS-FA) 7.1 函数使用 Kotlin函数使用关键字fun定义，除返回Unit、单表达式函数体外，需显式声明返回类型。 支持为类添加新的拓展函数(绑定实例调用)，且对只有一个参数的成员函数或拓展函数，支持用infix标注其为中缀函数。 函数参数支持：参数默认值(减少重载量)、可变数量参数、命名参数 函数可以声明在：文件顶层、局部作用域、成员函数、拓展函数 高阶函数是将函数用作参数或返回值的函数，如DoubleArray.filter() // f1是一个单表达式函数, 类型为 (Int, Int) -> Int;调用: f1(1, 1) fun f1(a: Int, b: Int) = a + b // f2的类型为 (Int, Int) -> () -> Int;返回一个Lambda表达式。求值需要两次调用: f2(1, 1)() fun f2(a: Int, b: Int) = { a + b } // 拓展函数，调用 \"1234567\".swap(0, 6) fun String.swap(i: Int, j: Int): String { val arr = this.toCharArray() val tmp = arr[i] arr[i] = arr[j] arr[j] = tmp return arr.concatToString() } // 拓展函数声明为中缀函数，调用 2.0 power 3 infix fun Double.power(x: Number): Double { return Math.pow(this, x.toDouble()) } open class NumUtil { // 函数参数支持设置默认值；可变数量参数用vararg声明(包装成Array处理),通常用在最后一个参数 open fun sum(init: Int = 0, time: Int = 1, vararg ns: Double): Double { return (init + ns.sum()) * time } } class MyUtil : NumUtil() { // 子类复写父类默认值参数，函数签名不能添加默认值且和父类使用相同默认值 override fun sum(init: Int, time: Int, vararg ns: Double): Double { // 定义匿名函数，并返回一个接受谓词的过滤函数 val doubleFilter = fun(): ((Double) -> Boolean) -> List { return ns::filter } var cnt = ns.size // 定义局部函数，并用Lambda表示谓词函数 // Lambda表达式总是被{}包裹，参数在->左侧，函数体在右。若只有一个参数可省略(编译器生成隐式名称it) fun filter() = doubleFilter()() Predicate@{ if (it > 0) { // return默认返回最近一层的 函数 或 匿名函数。此处仅返回Lambda需加标签限制 return@Predicate true } else { cnt-- // 可以修改闭包中捕获的变量，和Java不同 return@Predicate false } } // 变量ns类型为DoubleArray, 调用filter后将返回值转DoubleArray再展开为可变参数 return super.sum(init, time, *(filter().toDoubleArray())) } } fun main() { // 函数调用时可采用命名参数方式增强可读性 MyUtil().sum(init = 0, time = 2, 1.0, 2.0, 3.0) .run(::println) // 使用 :: 来引用一个函数 } 7.2 函数特性 尾递归: 支持用递归方式写循环逻辑(满足条件时，编译器将其优化为循环实现) 具体化的类型参数: 对于内联函数支持具体化参数类型reified,即可像普通类型一样对类型参数使用is/as 带接收者的函数字面值: 使用指定的 接收者对象 调用函数字面值的功能，可用于构建DSL语言 // 使用tailrec修饰，最后一个操作为调用自身且不能在try-catch-finally中 tailrec fun gcd(x: Int, y: Int): Int { return if (y == 0) x else gcd(y, x % y) } // 内联函数使用reified修饰类型参数后，可像普通类型一样使用T；调用：functionsOf() inline fun functionsOf() = T::class.memberFunctions functionsOf().joinToString(\"\\n\").let(::println) // 非内联函数不能使用具体化类型参数；调用functionsOf(String::class.java) fun functionsOf(clz: Class): Array = clz.declaredMethods functionsOf(String::class.java).joinToString(\"\\n\").let(::println) // 指定带接收者的函数字面值，赋值给变量func（或作为函数参数） val func = fun Int.(o: Number): Int = this + o.toInt() val result = 11.func(9) 7.3 高阶函数 高阶函数是将函数用作参数或返回值的函数，如DoubleArray.filter() // 匿名函数 var sum: (Int, Int) -> Int = fun(x: Int, y: Int): Int { return x + y } // Kotlin中将Lambda表达式当成匿名函数处理(无需显式return) sum = { x: Int, y: Int -> x + y } // 接受 (Int, Int)->Int 函数作为入参，返回 ()->Int 函数 fun calc(x: Int, y: Int, add: (Int, Int) -> Int) = { x * y - add(x, y) } val result = calc(2, 3, sum)() println(result) 7.4 DSL支持 利用Kotlin支持拓展函数、带接收者的函数字面值 这两个特性，可便捷地构建自定义的DSL。 注： DSL即领域专用语言(Domian-Specific Language)专注于特定问题领域的计算机语言(相对通用计算机语言GPL而言)； DSL聚焦与特定问题领域，功能简单但完备，更容易理解和使用。如Gradle基于Ant和Maven，用Groovy的DSL来声明项目设置。 class ReqWrapper { var url: String = \"\" var method: String = \"GET\" var body: RequestBody = \"\".toRequestBody() var timeout = Triple(3000L, 5000L, 8000L) private var _success: (String) -> Unit = { } private var _fail: (Throwable) -> Unit = {} fun onSuccess(onSuccess: (String) -> Unit) { _success = onSuccess } fun onFail(onError: (Throwable) -> Unit) { _fail = onError } companion object { // 指定init函数的接收者是ReqWrapper实例 fun creator(init: ReqWrapper.() -> Unit) { val wrap = ReqWrapper() wrap.init() executeForResult(wrap) } // 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.3' private fun executeForResult(wrap: ReqWrapper) = runBlocking(Dispatchers.IO) { if (wrap.url.isBlank()) { wrap._fail(IllegalArgumentException(\"url is empty\")) return@runBlocking } runCatching { // 'com.squareup.okhttp3:okhttp:4.9.3' val client = OkHttpClient.Builder() .connectTimeout(wrap.timeout.first, TimeUnit.MILLISECONDS) .readTimeout(wrap.timeout.second, TimeUnit.MILLISECONDS) .writeTimeout(wrap.timeout.third, TimeUnit.MILLISECONDS) .build() val req = when (wrap.method) { \"post\", \"Post\", \"POST\" -> Request.Builder().url(wrap.url).post(wrap.body).build() else -> Request.Builder().url(wrap.url).build() } return@runCatching client.newCall(req).execute().body?.string() ?: \"\" }.onSuccess(wrap._success) .onFailure(wrap._fail) } } } fun main() { val http = ReqWrapper.Companion::creator http { url = \"https://www.baidu.com\" onSuccess { println(it) } onFail { println(\"request failed\") it.printStackTrace() } } } 附： kotlinx.html分别提供了kotlinx-html-jvm和kotlinx-html-js库的DSL； 用于在JVM和浏览器/JS引擎中直接使用Kotlin代码来构建HTML，更加简洁纯净； 还能省略诸如JSP、Velocity、Freemarker等视图模板引擎直接用后端接口数据操作HTML元素。 "},"chapter8/8.与Java互操作.html":{"url":"chapter8/8.与Java互操作.html","title":"8. 与Java互操作","keywords":"","body":"8. 与Java互操作 8.1 Kotlin调Java 语法细节： 对Java中使用了Kotlin关键字的标识符，可使用反引号转义，如 obj.`is` Java中的void方法从Kotlin调用时返回Unit Java类的静态成员，在Kotlin中会构成该类的\"伴生对象\"，可直接显式访问JMain.main() Java类的getter/setter在Kotlin中可以直接简化为属性 异常: Kotlin中的异常都是非受检的，即使Java方法有声明抛出异常，编译器也不要求必须捕获 数组: 和Java不同Kotlin的数组是非型变的，Java的原生数组Kotlin中有对应的特定数组类，如int[]/IntArray 可变参数: Kotlin用展开运算符*来传递可变数量参数，如：Arrays.asList(*arrayOf(1, 2, 3)),若不展开返回List Java的类在Kotlin中为平台类型(无相应语法，仅有助记符)，会放宽空类型检查: T!表示T或T? (Mutable) Collection! 表示可变或不可变、可空或不可空的T的Java集合 Array! 表示可空或不可空的T(或T的子类型)的Java数组 对一部分Java类型，Kotlin会映射到相应的Kotlin类型,而非原样从Java加载 Java原生类型对应的非空类型，包装类型对应可空类型， 如:int/Int; Integer/Int? 映射部分java.lang.*为kotlin.*，如:Object/Any!; String/String!; Number/Number!; 对用作泛型参数的Java类型、集合类型、数组 会映射为Kotlin的平台类型 对Java的泛型执行一些转换（但运行时都会抹除类型信息）： 通配符转为声明处型变类型: Foo/Foo!; Foo/Foo! 原始类型转为星投影: List/List! Kotlin中对java.lang.Object的部分方法使用: getClass(): foo::class.java 或 foo.javaClass clone(): 需继承kotlin.Cloneable wait()/notify(): 可强转为java.lang.Object后调用 finalize(): 直接在类中声明protected fun finalize()对象销毁时会回调 反射用KtClass::class.java、ktObj::class.java、ktObj.javaClass获取java.lang.Class对象 对SAM(Single Abstract Method)类型的Java接口，Kotlin的函数字面值可被转换为该接口的实现。如 val obj = Runnable { }创建一个SAM转换的实例。 8.2 Java调Kotlin 语法细节： Kotlin中类的属性会被自动编译成getter/setter方法, 特别的val isOpen转成isOpen()/setOpen() 对Kotlin中@JvmField修饰的属性，不会生成getter/setter而是直接生成public的同名Java字段 Kotlin类中的命名对象或伴生对象会生成静态内部类，对象中@JvmStatic函数会额外生成外部类的静态方法 可见性：Kotlin中的private/protected保持不变，internal/public都转成public 对Kotlin中的object对象类成员，需使用obj.INSTANCE.xxx调用 对顶层的属性和函数会被转成类的静态方法，类名FileNameKt，也可自定义@file:JvmName(\"MyClassName\") Kotlin会为每个有默认值的参数都生成一个重载函数；默认Java中只可见完整参数的方法，可用@JvmOverloads放开 Kotlin可用注解@Throws(Exception::class)声明抛出Java中的受检异常 "},"chapter9/9.并发支持.html":{"url":"chapter9/9.并发支持.html","title":"9. 并发支持","keywords":"","body":"9. 并发支持 9.1 调用Java线程库 Kotlin没有synchronized、volatile关键字，且Any没有wait()、notify()/notifyAll()方法。 class Main { fun work() { // 使用线程创建/启动的拓展函数 thread(start = true, isDaemon = false, name = \"myThread\", priority = 5) { // do sth } } // 易变字段使用注解修饰 @Volatile private var data = \"\" @Synchronized // 同步方法用注解修饰 private fun sync() { synchronized(this) { // 同步块使用 synchronized 函数处理 } } } 9.2 使用协程库 协程是用户态的轻量级线程，用挂起替代了内核态线程阻塞，让原本需要用\"异步+回调\"的复杂逻辑简化成看似同步的简单逻辑 多进程：充分利用多CPU资源 多线程：充分利用CPU多核心的计算能力 事件驱动/协程：充分挖掘单核CPU的潜力 注: 进程最大线程数=(进程最大内存-JVM内存-OS保留内存)/线程栈的大小 协程是一种并发设计模式，用于简化异步执行的代码。通过协程管理耗时任务： 更轻量：支持在单个线程上运行多个协程，协程的挂起不会阻塞线程，比阻塞消耗内存更小且支持多个挂起操作。 管理方便：通过CoroutineScope结构化并发，能准确控制生命周期，减少内存泄露。 // implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:+' // 协程通过CoroutineScope作用域启动，协程内可访问CoroutineContext上下文 fun main() = runBlocking { /*新起协程*/ withContext(Dispatchers.IO) { println(\"work ${Thread.currentThread()}\") } println(\"main ${Thread.currentThread()}\") } 协程作用域CoroutineScope 负责跟踪和管理通过该Scope开启的协程，当调用cancel()方法时所有该域下的协程都会收到取消信号，且此后无法再开启新协程。 launch: 返回Job协程执行结果不返回给调用方；若执行过程有异常立即抛出。 async: 返回Deferred调用方可通过其await()方法获取执行结果；执行过程的异常在调用await()方法时抛出。 注: Android中常用的内置Scope有GlobalScope、ViewModel#viewModelScope、Lifecycle#lifecycleScope 协程上下文CoroutineContext 上下文有4个内容：调度器、句柄、协程名、异常处理器，除Job每次都会创建新的，其他参数优先级为：启动参数 > Parent上下文。 协程的Parent可以是CoroutineScope，也可以是另一个协程。 调度器Dispatcher 协程必须运行调度器里，协程可以将自己挂起，调度器负责恢复它们。 Dispatchers.Main：在主线程运行协程。 Dispatchers.IO：适合执行磁盘或网络I/O。 Dispatchers.Default：适合执行占用大量CPU资源的工作。 注: withContext()并不一定会切换线程：如果目标调度器和当前一致，则没有额外开销。 此外Kotlin还优化了Dispatchers.Default与 Dispatchers.IO之间的切换，以尽可能避免线程切换。 句柄Job Job实例唯一地标识一个协程，并且能管理这个协程地生命周期。通过launch/async()都会创建新的Job实例。 New/Active/Competing/Competed/Cancelling/Cancelled：状态可由isActive/isCancelled/isCompleted查询。 协程名CoroutineName 默认是\"coroutine\" 异常处理器CoroutineExceptionHandler 处理未捕获的异常 协程的使用 用suspend关键字修饰的方法，必须在协程中调用（但该关键字并不会让协程挂起） Kotlin使用栈帧管理协程中的函数与局部变量，协程挂起时保存栈帧，恢复时取出栈帧继续执行。 class UserViewModel(app: Application) : AndroidViewModel(app) { val userRepo = UserRepository() val userInfo: LiveData by lazy { // 不公开可变类型，把修改都集中到一起 MutableLiveData().also { viewModelScope.launch { // 在ViewModel中创建协程，避免使用GlobalScope try { it.value = userRepo.getUserInfo() }catch (e:Throwable){ // 关注异常 it.value = \"{}\" } } } } } class UserRepository(private val dispatcher: CoroutineDispatcher = Dispatchers.IO) { // 外部注入调度器而非写死 // suspend函数要保证主线程安全 // 数据层/业务层：公开suspend函数对外提供服务，公开Flow以接收数据更改通知 // 使用cancelable函数 或主动ensureActive()配合取消 suspend fun getUserInfo(): String = withContext(dispatcher) { return@withContext \"{}\"; } } 协程的取消 协程的取消需要内外协作，当外部调用cancel()后协程并不会马上取消，要取消还需要： 一种是主动检查退出：终止循环 或 抛出CancellationException, 如ensureActive() 当该协程内调用到挂起函数后：kotlinx.coroutines中的所有的suspend修饰函数，因为恢复时调度器会检查该协程状态。 挂起当前协程的方法 withContext(ctx){}：挂起当前协程，执行block并返回结果 Deferred#await()：获取目标协程执行完的结果 Job.join()：等待目标协程执行完成 delay(): 挂起当前协程，不久后恢复 yield(): 挂起当前协程，让出线程 coroutineScope({})：等待内部所有新协程完成才会恢复当前协程 suspendCoroutine/suspendCancellableCoroutine({})：挂起当前协程，等待将来主动恢复(通常用于等回调) // 等待多个任务都执行完 suspend fun fetchData(urls: List) = withContext(Dispatchers.IO) { val dataMap = ConcurrentHashMap() // coroutineScope 等所有子协程都执行完，如有异常直接抛出 coroutineScope { val deferredList = ArrayList>() for (url in urls) { // in fetch update dataMap[url]=get(url) deferredList.add(async { fetch(url, dataMap) }) } // deferredList.awaitAll() 不用await也会等待 } (mData as MutableLiveData).postValue(dataMap) } // 将回调改为方法返回 suspend fun format(dataStr: String): Long { // suspendCancellableCoroutine 挂起协程后，当前协程被取消时，会抛出一个CancellationException return suspendCoroutine { c: Continuation -> runCatching { SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\", Locale.CHINA).parse(dataStr)?.time }.onSuccess { // 这里用于模拟Callback的情况 it?.also { c.resume(it) } ?: c.resumeWithException(DataFormatException(\"\")) }.onFailure { c.resumeWithException(it) // 将异常抛给调用方 } } } "},"chapter10/10.工具附录.html":{"url":"chapter10/10.工具附录.html","title":"10. 工具附录","keywords":"","body":"10. 工具附录 10.1 作用域函数 返回调用对象: apply(): 输入对象在块中通过this引用，多用于在初始化实例时，操作对象属性并最终返回该对象。 also(): 输入对象在块中通过it引用，常用于链式调用 返回匿名函数的值: run(): 输入对象在块中通过this引用 let(): 输入对象在块中通过it引用，多用于统一处理对象不为空的情况 with(obj){ }: 输入对象在块中通过this引用，适用于调用对象的多个函数 val obj = Any() // 仍然返回输入对象 obj.apply { hashCode() }.apply { toString() } obj.also { it.hashCode() }.also { it.toString() } // 返回匿名函数的值 obj.run { hashCode() } obj?.let { it.toString() } // with不是拓展函数，返回匿名函数的值 with(obj) { obj.hashCode() obj.toString() } 10.2 正则表达式 Kotlin中除可使用Java的Pattern、Matcher外，还提供了Regex类： 构造: regex = Regex(\"[a-z]+\", RegexOption.IGNORE_CASE) regex = \"[a-z]+\".toRegex() 匹配： 是否全部匹配: regex.matches(inputStr) 是否至少有一个匹配: regex.containsMatchIn(inputStr) 全部匹配结果: regex.matchEntire(inputStr),若不匹配返回null 替换： 替换匹配部分: val replaced = regex.replace(input, replacement) 匹配转换: val replaced = regex.replace(input, transform) 查找： 查找首个匹配: val result = regex.find(input) 查找所有匹配: val resultSequence = regex.findAll(input) 转换为Java正则API: Pattern: val pattern = regex.toPattern() Matcher: val matcher = pattern.matcher(input) 10.3 文件IO 标准IO 读取readLine()得到String，进而可通过toXx()转换。 输出print() 文件操作 读: file.readText()/readLines()/readBytes() file.reader()/bufferedReader/inputStream() 写: file.writeText()/appendText()/writeBytes() file.writer()/bufferedWriter()/outputStream() 遍历文件树: file.walk().iterator() 文件/目录复制: file.copyRecursively() 网络IO 读: url.readText()/readBytes() 写: url.openConnection().getOutputStream() 拓展执行Shell命令 Shell命令在Java中使用Runtime.getRuntime().exec(cmdStr)执行。 fun String.execute(): Process { return Runtime.getRuntime().exec(this) } fun Process.text(): String { val input = BufferedReader(InputStreamReader(this.inputStream)) val output = StringBuilder() var line: String? do { line = input.readLine()?.also { output.appendLine(it) } } while (line != null) return output.toString() } fun main() = runBlocking(Dispatchers.IO) { val p = \"ls -al\".execute() println(\"exitCode:${p.waitFor()}, text:${p.text()}\") } "}}