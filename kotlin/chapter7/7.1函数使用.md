# 7.1 函数使用

- Kotlin函数使用关键字`fun`定义，除返回Unit、单表达式函数体外，需显式声明返回类型。
- 支持为类添加新的拓展函数(绑定实例调用)，且对只有一个参数的成员函数或拓展函数，支持用`infix`标注其为中缀函数。
- 函数参数支持：参数默认值(减少重载量)、可变数量参数、命名参数
- 函数可以声明在：文件顶层、局部作用域、成员函数、拓展函数
- 高阶函数是将函数用作参数或返回值的函数，如`DoubleArray.filter()`


```kotlin
// f1是一个单表达式函数, 类型为 (Int, Int) -> Int;调用: f1(1, 1)
fun f1(a: Int, b: Int) = a + b

// f2的类型为 (Int, Int) -> () -> Int;返回一个Lambda表达式。求值需要两次调用: f2(1, 1)()
fun f2(a: Int, b: Int) = { a + b }

// 拓展函数，调用 "1234567".swap(0, 6)
fun String.swap(i: Int, j: Int): String {
    val arr = this.toCharArray()
    val tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
    return arr.concatToString()
}

// 拓展函数声明为中缀函数，调用 2.0 power 3
infix fun Double.power(x: Number): Double {
    return Math.pow(this, x.toDouble())
}

open class NumUtil {
    // 函数参数支持设置默认值；可变数量参数用vararg声明(包装成Array处理),通常用在最后一个参数
    open fun sum(init: Int = 0, time: Int = 1, vararg ns: Double): Double {
        return (init + ns.sum()) * time
    }
}

class MyUtil : NumUtil() {
    // 子类复写父类默认值参数，函数签名不能添加默认值且和父类使用相同默认值
    override fun sum(init: Int, time: Int, vararg ns: Double): Double {
        // 定义匿名函数，并返回一个接受谓词的过滤函数
        val doubleFilter = fun(): ((Double) -> Boolean) -> List<Double> { return ns::filter }
        var cnt = ns.size

        // 定义局部函数，并用Lambda表示谓词函数
        // Lambda表达式总是被{}包裹，参数在->左侧，函数体在右。若只有一个参数可省略(编译器生成隐式名称it)
        fun filter() = doubleFilter()() Predicate@{
            if (it > 0) {
                // return默认返回最近一层的 函数 或 匿名函数。此处仅返回Lambda需加标签限制
                return@Predicate true
            } else {
                cnt-- // 可以修改闭包中捕获的变量，和Java不同
                return@Predicate false
            }
        }
        // 变量ns类型为DoubleArray, 调用filter后将返回值转DoubleArray再展开为可变参数
        return super.sum(init, time, *(filter().toDoubleArray()))
    }
}

fun main() {
    // 函数调用时可采用命名参数方式增强可读性
    MyUtil().sum(init = 0, time = 2, 1.0, 2.0, 3.0)
        .run(::println) // 使用 :: 来引用一个函数
}
```