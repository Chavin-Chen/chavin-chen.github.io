# 8.1 Kotlin调Java

1. 语法细节：
    - 对Java中使用了Kotlin关键字的标识符，可使用反引号转义，如 <kbd>obj.\`is\`</kbd>
    - Java中的void方法从Kotlin调用时返回`Unit`
    - Java类的静态成员，在Kotlin中会构成该类的"伴生对象"，可直接显式访问`JMain.main()`
    - Java类的`getter/setter`在Kotlin中可以直接简化为属性
    - 异常: Kotlin中的异常都是非受检的，即使Java方法有声明抛出异常，编译器也不要求必须捕获
    - 数组: 和Java不同Kotlin的数组是非型变的，Java的原生数组Kotlin中有对应的特定数组类，如`int[]/IntArray`
    - 可变参数: Kotlin用展开运算符`*`来传递可变数量参数，如：`Arrays.asList(*arrayOf(1, 2, 3))`,若不展开返回`List<IntArray>`
2. Java的类在Kotlin中为平台类型(无相应语法，仅有助记符)，会放宽空类型检查:
    - `T!`表示`T`或`T?`
    - `(Mutable) Collection<T>!` 表示可变或不可变、可空或不可空的T的Java集合
    - `Array<(out) T>!` 表示可空或不可空的T(或T的子类型)的Java数组
3. 对一部分Java类型，Kotlin会映射到相应的Kotlin类型,而非原样从Java加载
    - Java原生类型对应的非空类型，包装类型对应可空类型， 如:`int/Int; Integer/Int?`
    - 映射部分`java.lang.*`为`kotlin.*`，如:`Object/Any!; String/String!; Number/Number!;`
    - 对用作泛型参数的Java类型、集合类型、数组 会映射为Kotlin的平台类型
4. 对Java的泛型执行一些转换（但运行时都会抹除类型信息）：
    - 通配符转为声明处型变类型: `Foo<? extends Bar>/Foo<out Bar!>!; Foo<? super Bar>/Foo<in Bar!>!`
    - 原始类型转为星投影: `List/List<*>!`
5. Kotlin中对java.lang.Object的部分方法使用:
    - `getClass()`: `foo::class.java` 或 `foo.javaClass`
    - `clone()`: 需继承`kotlin.Cloneable`
    - `wait()/notify()`: 可强转为`java.lang.Object`后调用
    - `finalize()`: 直接在类中声明`protected fun finalize()`对象销毁时会回调
6. 反射用`KtClass::class.java、ktObj::class.java、ktObj.javaClass`获取`java.lang.Class`对象
7. 对SAM(Single Abstract Method)类型的Java接口，Kotlin的函数字面值可被转换为该接口的实现。如 `val obj = Runnable { }`创建一个SAM转换的实例。
