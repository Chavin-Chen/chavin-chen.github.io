# 3.6 委托
在委托模式(亦代理模式)中，有两个对象参与请求处理：接受请求的对象将请求委托给代理对象处理：
- 代理是一种基础处理，状态模式、策略模式、访问者模式中都有代理操作。
- 代理用聚合来代替继承，复用并降低耦合，还可以模拟`mixin`混合类型。

Kotlin在语言层面通过`by`关键字对代理做了支持。

## 类的委托
类中的方法被调用时，会转发给另一个对象(该对象类型实现了同样的接口)

```kotlin
interface ISubject {
    fun doSth()
    fun doOther()
}

class RealSubject() : ISubject {
    override fun doSth() = println("real do sth")
    override fun doOther() = println("real do other")
}

// 对ISubject的方法默认转发给sub对象
class WrapperSubject(val sub: ISubject) : ISubject by sub { 
    override fun doOther() {
        println("wrapper do other")
        sub.doOther() // 手动转发请求
    }
}
```

## 属性委托
类中的属性在声明时需要赋值，属性委托赋予属性富有变化的活力：

1. 懒加载`fun lazy()`：属性值在首次访问属性时执行Lambda计算，以后直接返回结果；局部变量也支持惰性初始化。
2. 延迟初始化`Delegates.notNull`：适用于无法在初始化阶段确定值的非空属性，若访问时仍未初始化会抛异常，类似`lateinit`。
3. 可观察属性`Delegates.observable`：监听器会收到有关属性变更的通知。
4. 可否决属性`Delegates.vetoable`：当收到属性变更通知时，可选择接受或否决变更。
5. 属性Map管理 和 自定义属性委托：属性不在类中直接定义，而是托付给一个代理对象统一管理。


```kotlin
// (1)懒加载属性委托
internal class User {
    // 默认是 LazyThreadSafetyMode.SYNCHRONIZED：保证仅一个线程执行一次初始化
    val name by lazy { String("Hello".toByteArray()) + "World" }
    // LazyThreadSafetyMode.PUBLICATION：可多个线程执行初始化，但仅使用最先返回的值
    val age by lazy(LazyThreadSafetyMode.PUBLICATION) { Math.random() }
    // 对多线程不做干涉，仅单线程初始化场景下结果可预知（性能最好）
    val sex by lazy { 1 == Math.random().toInt() and 1 }
}

// (2)非空属性，延迟初始化
class User {
    var s: String by Delegates.notNull()
    lateinit var t: String
}

// (3)可观察属性
class User {
    // implementation "org.jetbrains.kotlin:kotlin-reflect:+"
    val addr by Delegates.observable("") { p: KProperty<*>, old: String, new: String ->
        println("${p.name} changed from $old to $new")
    }
}

// (4)可否决属性
class User {
    val addr by Delegates.vetoable("") { p: KProperty<*>, old: String, new: String ->
        return@vetoable new.isBlank() // 不接受空地址
    }
}

// (5)属性委托给Map
class User(info: MutableMap<String, Any?>) {
    val name: String? by info
    val age: Int? by info
    val sex: Boolean? by info

}
val u = User(mutableMapOf<String, Any?>(
    "name" to "Allen",
    "sex" to false
).withDefault { null })

// (6)自定义属性委托
class User(var firstName: String, var lastName: String) {
    val name: String by Delegate() // Kotlin会生成辅助属性 name$delegate

    // 代理类需 getValue/setValue() 操作符函数, 参见 ReadWriteProperty
    private class Delegate : ReadOnlyProperty<User, String> {
        override operator fun getValue(thiRef: User, property: KProperty<*>): String {
            return "${thiRef.firstName}·${thiRef.lastName}"
        }
    }
}
```
