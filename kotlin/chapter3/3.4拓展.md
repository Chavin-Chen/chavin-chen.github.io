# 3.4 拓展
拓展函数和拓展属性用于向类添加新特性而无需继承或使用装饰器模式，拓展通常在顶层包中定义。

*注*:
- 若成员函数签名和扩展函数一致时，会优先使用成员函数。
- 扩展是一种静态行为(父类子类有同名拓展时，父类对象调用不会执行子类的扩展)，也不会影响被扩展类的字节码。
- 扩展的接受者是静态绑定的，但拓展的分发者可以动态绑定。

```kotlin
package com.chavin.kt
// 拓展函数
fun <T> MutableList<T>.swap(i: Int, j: Int): MutableList<T> {
    val t = this[i]
    this[i] = this[j]
    this[j] = t
    return this
}
// 拓展属性，只能扩展val属性
val CharSequence.initial
    get():Char? {
        if (this.isEmpty()) return null
        return this[0].uppercaseChar()
    }


// 扩展接受者：静态绑定
class Util
open class Base {
    // Base是扩展分发者：动态绑定
    open fun Util.u() {
        println("Base.u()")
    }
    fun call(util: Util) {
        util.u()
    }
}
class Child : Base() {
    override fun Util.u() {
        println("Child.u()")
    }
}
fun main() {
    // 输出: Child.u()
    val p: Base = Child()
    p.call(Util())
}
```
