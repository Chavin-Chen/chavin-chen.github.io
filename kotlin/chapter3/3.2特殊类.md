# 3.2 特殊类

## 嵌套类
- 普通嵌套类: 相当于Java中静态内部类,不持有外部类隐式引用的。
- 内部类: `inner`修饰的内部类会带有一个外部类对象的引用`this@Outer`。
- 匿名内部类: 通常伴随着匿名对象的创建。

```kotlin
class Outer(val value: Int) {
    class Nested { /* 嵌套类不能访问外部类成员 */ }
    inner class Inner(val key: Int = value) { /* 可以访问外部类成员 */ }

    init {
        val obj = object : Runnable {  // 可使用Lambda: obj={ /* do sth */ }
            override fun run() { /* 可以访问外部类成员 */ }
        }
    }
}
```

## 数据类
- 数据类只能是`final`的，可以拓展自其他类，但不能是`abstract/open/sealed/inner`修饰的。
- 主构造器至少有一个标记为`val/var`的参数，可以使用参数默认值。
- 根据属性自动生成：
    - `equals/hashCode()`
    - `toString()`, 形如`User(name=Nancy, age=10)`
    - `copy()`
    - `componentN()` 按声明顺序生成`component1(),component2()...`用于解构

```kotlin
final data class User(val name: String, val age: Int)

fun main(args: Array<String>) {
    val user1 = User("Allen", 12)
    val (name, age) = user1 // 解构
    val user2 = user1.copy("Bob") // 处理拷贝
    println(user1.copy() == user1) // true:自动生成hashCode()/equals()对比内容
}
```

### 元组
Kotlin为同类型元素的元组添加了`toList()`拓展函数:
- 二元组: `data class Pair<out A, out B>`
- 三元组: `data class Triple<out A, out B, out C>`

### Java只保存数据的领域实体类
- POJO：Plain Ordinary / Pure Old Java Object，只具有一些getter/setter的类对象。
- DTO：Data Transfer Object，用于展示层与服务层之间的数据传输对象。
- VO：ViewObject或ValueObject。
- PO：Persisent Object，持久层使用的持久化对象。
- BO：Business Object，业务层使用的描述事务的实体对象，如BBS的文章、评论、用户。
- DO：Domain Object，领域对象，从现实世界抽象出的业务实体。


## 枚举类
枚举用`enum class`声明: 枚举类是final的不可派生, 枚举常量是单例对象(多个用逗号分隔)。

```kotlin
// 声明枚举类；枚举常量是一个对象
enum class RGB(val argb: Int) {
    RED(0x01FF0000) { // 枚举常量可以声明自己的匿名类
        override val alpha: Int
            get() = 0
    },
    GREEN(0x0000FF00), BLUE(0x000000FF);

    open val alpha: Int = argb shr 48
}

// 使用 enumValues()列出所有枚举值    
println(enumValues<RGB>().joinToString { "${it.name}:${it.ordinal}=${it.argb}" })
val red = RGB.values()[0]
var res = RGB.valueOf("Red") // 从字符串构建实例，找不到就抛异常

// kotlin的枚举类型定义
public abstract class Enum<E : Enum<E>>(name: String, ordinal: Int) : Comparable<E> {
    public final val name: String  // 枚举对象名
    public final val ordinal: Int  // 下标位置，从0开始
}
```

## 密封类
密封和枚举都是为了限制类的继承结构(限制实例或派生类数量)，`sealed`不能修饰抽象类和接口。
- enum类：枚举类是final的，枚举常量只存在一个实例。
- sealed类：密封类的子类是final的，但子类可以有包含状态的多个实例。

```kotlin
sealed class Expression

class Num(var n: Double) : Expression()
class Sum(var a: Expression, var b: Expression) : Expression()
class Sub(var a: Expression, var b: Expression) : Expression()

fun eval(e: Expression): Double = when (e) { // when无需添加else
    is Num -> e.n
    is Sub -> eval(e.a) - eval(e.b)
    is Sum -> eval(e.a) + eval(e.b)
}
```

## 注解类
Kotlin的注解和Java注解完全兼容：

```kotlin
@Target(AnnotationTarget.CLASS) // 修饰对象
@Retention(AnnotationRetention.RUNTIME) // 注解保存策略
@Repeatable // 可重复修饰
@MustBeDocumented // 支持出现在自动生成的API文档中
// 声明注解类
annotation class SPI(val insType: InsType = InsType.STANDARD) {
    enum class InsType { SINGLE, STANDARD }
}

@SPI(SPI.InsType.SINGLE) // 使用注解
interface PrintService {
    fun print()
}
```
