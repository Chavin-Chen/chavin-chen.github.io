# 3.3 继承
Koltin的类默认是`final`的，需显式声明为`open`或`abstract`才可被继承，且只支持单继承类，但可以实现多个接口。

*注*: 
- 基类构造函数或初始化块中不能使用`open`修饰的字段，因为被覆盖的字段可能初始化还没完成。
- 继承耦合度高，应优先考虑用组合替换继承。

```kotlin
interface ISpeaker {
    // 接口可以声明抽象属性，抽象属性可不用初始化
    val name: String

    // 接口的属性也可以提供访问器
    var owner: String
        get() = ""
        set(value) {}

    // 接口方法默认是抽象的，但可以有默认实现
    fun introduce() = println("Hi everyone,my name is $name")
}

interface IHuman {
    fun introduce() = println("Are you OK?")
}

abstract class AbsPerson : IHuman {
    // 抽象函数是open的
    abstract fun work()

    // abstract或open类中的非抽象函数默认是final的，若要复写需显式声明open
    open fun rest() = println("Resting")
}

// 只能基础一个父类，可以实现多个接口
class Programmer : AbsPerson, ISpeaker {
    // 基类为的val字段子类可声明为var，相当于加多一个set方法。反之则不行
    override var name: String = ""

    // 若子类无主构造函数，必须在次构造函数中用super()形式调用父类构造函数
    constructor(name: String) : super() {
        this.name = name
    }

    // 覆盖冲突时候，使用super<>语法调指定父类方法
    override fun introduce() {
        super<ISpeaker>.introduce()
        super<AbsPerson>.introduce()
        println("I'm fine, thks")
    }

    override fun work() {
        println("Writing code")
        this.rest()
    }

    // override函数默认是open的，可加final修饰禁止重写
    final override fun rest() {
        println("Close eyes")
        super.rest()
    }
}
```

## 接口与抽象类
接口：定义了一些行为规约(接口间可通过继承拓展)；Kotlin的接口可以包含属性声明，也可以包含方法默认实现。

抽象类：含有抽象函数的类(需用abstract修饰)为抽象类。

1. 概念上：
    - 接口是对动作的抽象，定义了行为特性的规约。
    - 类是对一类事物的抽象，包含了事物属性与行为。
2. 语法上：
    - 接口不能保存状态，一个类可以实现多个接口。
    - 抽象类可以有非抽象属性和方法，一个类只能继承一个父类。
3. 设计上：
    - 接口时辐射式设计，接口变更了所有实现类都需变更。
    - 抽象类是模板式设计，抽象类新增方法子类可以不变更。
4. 应用上：
    - 接口的实现者和接口是has-a关系，耦合程度更低。
    - 继承者和抽象类is-a关系，是强耦合的（优先应考虑组合：实现多接口组合、成员依赖）。

