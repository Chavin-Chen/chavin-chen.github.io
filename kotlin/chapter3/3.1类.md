# 3.1 类
在面向对象的命令式(imperative)编程里,提倡针对具体问题建立专门的数据结构,相关操作以方法的形式附加到数据结构上,自顶向下地构建虚拟世界:
- 1个思想：一切皆对象。
- 4个特性：抽象、封装、继承、多态。
- 7个原则：SOLID' + 合成复用(组合优于继承)。
- 23种模式：GOF。

类用`class`声明，类中可以包含 构造函数、初始化块、成员字段、成员函数、对象声明/嵌套类/内部类。

可见性修饰：
- `public`: 公开访问，Kotlin类成员默认public。
- `internal`: 模块内可见(Java9引入模块概念，通常指一个项目Module/Jar)。
- `protected`: 派生类可见；成员覆盖后默认还是protected。
- `private`: 顶层声明仅文件内可见，类中声明仅本类中可见。


```kotlin
// 类默认是`public final`不可继承的，如需复写父类要添加open修饰
// 如主构造器无注解和可见性修饰,可省略constructor；主构造的参数可以在字段初始化和初始化块中用
// 默认会生成public的无参主构造，主构造参数添加val/var修饰使对应参数成为成员字段
class Foo protected constructor(val arg: String) : Any() {
    // 非抽象的属性必须初始化,默认public
    var value: Int = 0
        get() {
            println("getValue...")
            return field
        }
        set(value) {
            println("setValue")
            field = value
        }

    // 使用lateinit修饰非空可变字段以延迟初始化
    lateinit var value1: String

    init { // 主构造函数不含代码，初始化块会最终合成主构造函数体
    }

    // 可包含若干次构造函数，并需调用主构造函数
    constructor(i: Int) : this("") {
    }

    // 函数默认是public final的
    fun doSth(): Unit {
        if (this::value1.isInitialized) {
            value1 = ""
        }
        // 指定父类方法调用，使用于基类和接口中方法名冲突时(覆盖冲突)
        super<Any>.hashCode()
    }
}

// 对顶层字段或object的成员(不能自定义getter)添加`const`修饰
// 使之成为编译器常量(public static final,只能用基本类型值或String初始化)
const val CONST: String = "this is a constant"

// 非基本类型的顶层属性，可以用lateinit修饰
lateinit var x: String
fun main(args: Array<String>) {
    // Kotlin没有new关键字，调用构造函数即创建新对象
    val foo = Foo() 

    // 非基本类型的局部变量，可以用lateinit修饰
    lateinit var y: List<Int> 
    if (!::x.isInitialized) {
        x = ""
    }
}
```
