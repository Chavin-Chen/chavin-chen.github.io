# 5.2 运算符重载

重载操作符的函数需要用`operator` 修饰符标记，中缀操作符的函数使 用`infix`命名函数修饰。

1. 一元操作符: 
    - +a: `a.unaryPlus()`
    - -a: `a.unaryMinus()`
    - !a: `a.not()`
    - a++、++a: `a.inc()` 与C++不同，Kotlin会自动区分前后缀调用
    - a--、--a: `a.dec()`
2. 二元操作符: `a#b => a.func(b)`
    - 算术`+ - * / % ..`: `plus() minus() times() div() rem/mod() rangeTo()`
    - 包含`in !in`: `contains()`
    - 索引`a[i]=a[j]`: `get() set()`
    - 调用`a(b)`: `a.invoke(b)`
    - 复合赋值: `a.xxxAssign(b)` 其中xxx为算术运算符函数
    - 相等`== !=`: `equals()`
    - 比较: `a.compareTo(b) # 0` 其中#为 `< > <= >=`

*注*：在IDE中 `CTRL/CMD + ML`点击运算符可跳转函数定义。

例如，当编译器处理表达式`+a`时，它将执行以下步骤:
1. 确定a的类型，令其为T。
2. 为接收者T查找一个带有`operator`修饰符的无参函数`unaryPlus()`，即成员函数或扩展函数。
3. 如果函数不存在或不明确，则导致编译错误。
4. 如果函数存在且其返回类型为R，则表达式`+a`的值类型为R。



