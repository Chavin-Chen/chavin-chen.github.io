# 9.2 使用协程库

协程是用户态的轻量级线程，用挂起替代了内核态线程阻塞，让原本需要用"异步+回调"的复杂逻辑简化成看似同步的简单逻辑
- 多进程：充分利用多CPU资源
- 多线程：充分利用CPU多核心的计算能力
- 事件驱动/协程：充分挖掘单核CPU的潜力


*注*: 
- 进程最大线程数=(进程最大内存-JVM内存-OS保留内存)/线程栈的大小
- 协程是一种并发设计模式，用于简化异步执行的代码。通过协程管理耗时任务：
    - 更轻量：支持在单个线程上运行多个协程，协程的挂起不会阻塞线程，比阻塞消耗内存更小且支持多个挂起操作。
    - 管理方便：通过`CoroutineScope`结构化并发，能准确控制生命周期，减少内存泄露。


```kotlin
// implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:+'
// 协程通过CoroutineScope作用域启动，协程内可访问CoroutineContext上下文
fun main() = runBlocking {
    /*新起协程*/
    withContext(Dispatchers.IO) {
        println("work ${Thread.currentThread()}")
    }
    println("main ${Thread.currentThread()}")
}
```

## 协程作用域CoroutineScope

负责跟踪和管理通过该Scope开启的协程，当调用`cancel()`方法时所有该域下的协程都会收到取消信号，且此后无法再开启新协程。
- `launch`: 返回`Job`协程执行结果不返回给调用方；若执行过程有异常立即抛出。
- `async`: 返回`Deferred`调用方可通过其`await()`方法获取执行结果；执行过程的异常在调用`await()`方法时抛出。

*注*: Android中常用的内置Scope有`GlobalScope`、`ViewModel#viewModelScope`、`Lifecycle#lifecycleScope`

## 协程上下文CoroutineContext
上下文有4个内容：调度器、句柄、协程名、异常处理器，除Job每次都会创建新的，其他参数优先级为：`启动参数 > Parent上下文`。
协程的Parent可以是`CoroutineScope`，也可以是另一个协程。

### 调度器Dispatcher
协程必须运行调度器里，协程可以将自己挂起，调度器负责恢复它们。
- Dispatchers.Main：在主线程运行协程。
- Dispatchers.IO：适合执行磁盘或网络I/O。
- Dispatchers.Default：适合执行占用大量CPU资源的工作。

*注*: `withContext()`并不一定会切换线程：如果目标调度器和当前一致，则没有额外开销。
此外Kotlin还优化了`Dispatchers.Default`与 `Dispatchers.IO`之间的切换，以尽可能避免线程切换。

### 句柄Job
Job实例唯一地标识一个协程，并且能管理这个协程地生命周期。通过launch/async()都会创建新的Job实例。
New/Active/Competing/Competed/Cancelling/Cancelled：状态可由`isActive/isCancelled/isCompleted`查询。

### 协程名CoroutineName
默认是`"coroutine"`

### 异常处理器CoroutineExceptionHandler
处理未捕获的异常


## 协程的使用
用`suspend`关键字修饰的方法，必须在协程中调用（但该关键字并不会让协程挂起）
Kotlin使用栈帧管理协程中的函数与局部变量，协程挂起时保存栈帧，恢复时取出栈帧继续执行。

```kotlin
class UserViewModel(app: Application) : AndroidViewModel(app) {
    val userRepo = UserRepository()

    val userInfo: LiveData<String> by lazy { // 不公开可变类型，把修改都集中到一起
        MutableLiveData<String>().also {
            viewModelScope.launch { // 在ViewModel中创建协程，避免使用GlobalScope
                try {
                    it.value = userRepo.getUserInfo()
                }catch (e:Throwable){ // 关注异常
                    it.value = "{}"
                }
            }
        }
    }
}

class UserRepository(private val dispatcher: CoroutineDispatcher = Dispatchers.IO) {
    // 外部注入调度器而非写死
    // suspend函数要保证主线程安全
    // 数据层/业务层：公开suspend函数对外提供服务，公开Flow以接收数据更改通知
    // 使用cancelable函数 或主动ensureActive()配合取消
    suspend fun getUserInfo(): String = withContext(dispatcher) {
        return@withContext "{}";
    }
}
```

### 协程的取消
协程的取消需要内外协作，当外部调用`cancel()`后协程并不会马上取消，要取消还需要：
- 一种是主动检查退出：终止循环 或 抛出CancellationException, 如`ensureActive()`
- 当该协程内调用到挂起函数后：`kotlinx.coroutines`中的所有的suspend修饰函数，因为恢复时调度器会检查该协程状态。


### 挂起当前协程的方法
- `withContext(ctx){}`：挂起当前协程，执行block并返回结果
- `Deferred#await()`：获取目标协程执行完的结果
- `Job.join()`：等待目标协程执行完成
- `delay()`: 挂起当前协程，不久后恢复
- `yield()`: 挂起当前协程，让出线程
- `coroutineScope({})`：等待内部所有新协程完成才会恢复当前协程
- `suspendCoroutine/suspendCancellableCoroutine({})`：挂起当前协程，等待将来主动恢复(通常用于等回调)

```kotlin
// 等待多个任务都执行完
suspend fun fetchData(urls: List<String>) = withContext(Dispatchers.IO) {
    val dataMap = ConcurrentHashMap<String, String>()
    // coroutineScope 等所有子协程都执行完，如有异常直接抛出
    coroutineScope {
        val deferredList = ArrayList<Deferred<Any?>>()
        for (url in urls) {
            // in fetch update dataMap[url]=get(url)
            deferredList.add(async { fetch(url, dataMap) }) 
        }
//      deferredList.awaitAll() 不用await也会等待
    }
    (mData as MutableLiveData).postValue(dataMap)
}

// 将回调改为方法返回
suspend fun format(dataStr: String): Long {
    // suspendCancellableCoroutine 挂起协程后，当前协程被取消时，会抛出一个CancellationException
    return suspendCoroutine { c: Continuation<Long> ->
        runCatching {
            SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS", Locale.CHINA).parse(dataStr)?.time
        }.onSuccess { // 这里用于模拟Callback的情况
            it?.also { c.resume(it) } ?: c.resumeWithException(DataFormatException(""))
        }.onFailure {
            c.resumeWithException(it) // 将异常抛给调用方
        }
    }
}
```
