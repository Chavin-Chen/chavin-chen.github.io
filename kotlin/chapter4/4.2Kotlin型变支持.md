# 4.2 Kotlin型变支持

## 使用处型变
Kotlin舍弃了类型通配符，在使用侧型变是用`out/in`修饰带来的类型投影(通过移除类的某些方法来限制使用)完成：

- 只读(类似`? extends T`)：`Array<out T>`只保证**取出**数据的类型安全，即只能调返回T的方法，集合对象是生产者
- 只写(类似`? super T`)：`Array<in T>`只保证**写入**数据的类型安全，即只能调传入T的方法，集合对象是消费者
- 原生无界通配(对应`?`)：`Array<*>`只能取出Any?，只能写入Nothing


```kotlin
public class Array<T> {}

fun copy(dist: Array<in Int>, src: Array<out Number>) {
    // in T: 对于dist只能调用传入T的方法，投影移除了返回T的方法
    // out T: 对于src只能调用返回T的方法，投影移除了传入T的方法
    for (i in src.indices) {
        dist[i] = src[i].toInt()
    }
}

fun main(args: Array<String>) {
    val nArr: Array<Number> = arrayOf(1)
    val iArr: Array<Int> = arrayOf(1)
    copy(nArr, iArr)
    copy(iArr, nArr)
}
```


## 声明处型变
对于类型中只存在某一类方法（只返回T，或只传入T），可以在泛型声明时添加协变修饰，此后该泛型类为支持型变的类型。
- 只有返回T的方法（生产者，用`out T`），支持协变是类型安全的
- 只有传入T的方法（消费者，用`in T`），支持逆变是类型安全的

```kotlin
// 声明支持协变
interface List<out E> : Collection<E> {}

// 声明支持逆变
interface Comparable<in T> {}


val list: List<Number> = listOf<BigInteger>() // 协变
val numCmp = object : Comparable<Number> {
    override fun compareTo(other: Number): Int {
        return 0
    }
}
val cmp: Comparable<Double> = numCmp // 逆变
```


## 类型投影
在不感知类型参数的情况下，可使用星投影语法`<*>`声明一个泛型类的类型投影：改投影类型可以接受目标泛型类的任意实例（类似Java`<?>`），但读写时有限制：

- 对于泛型`Foo<out T : TUpper>`，投影类型`Foo<*>` 等价于 `Foo<out TUpper>`：当T未知时，可以安全地从`Foo <*>`读取`TUpper`值。
- 对于泛型`Foo<in T>`，投影类型`Foo<*>`等价于`Foo<in Nothing>`：当T未知时，不能安全地向`Foo <*>`写入任何值。
- 对于泛型`Foo<T: TUpper>`: 
    - 读取值时投影类型`Foo<*>`等价于`Foo<out TUpper>`。
    - 写入值时投影类型`Foo<*>`等价于`Foo<in Nothing>`。

*注*：
- 如果泛型类有多个类型参数，每个类型参数都可以单独投影；
- 对比Kotlin类型投影`List<*>`和Java无界限通配符`List<?>`：
    - 读取：Kotlin星投影语法可取出`类型上限`，Java无界通配符只能取出`Object`。
    - 写入：Kotlin星投影语法不能写入(`in Nothing`)，Java无界通配符只能写入`null`。


```kotlin
class Test<in T, out U : CharSequence, V : Number>(
    private var t: T,
    val u: U,
    var v: V
) {
    fun setT(arg: T) {
        t = arg
    }
}

fun main(args: Array<String>) {
    val t: Test<*, *, *> = Test<Any?, String, Int>(null, "", 0)
//    t.setT(Nothing);              // Test<in Nothing>
    val chs: CharSequence = t.u     // Test<out CharSequence>
    val obj: Number = t.v           // Test<in Nothing> Test<out Number>
//    t.v = 0                       // ERROR: Setter for 'v' is removed by type projection
}
```


