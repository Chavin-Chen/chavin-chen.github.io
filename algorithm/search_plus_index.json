{"./":{"url":"./","title":"1. 算法复杂度","keywords":"","body":"1. 算法复杂度 时间复杂度 T(n)=O(f(n))：表示随问题规模n的增大算法执行时间的增长率和f(n)的增长率相同，即算法的时间复杂度。其中f(n)是问题规模n的函数（算法核心代码的执行次数）。 大O记法：用1取代常数、只保留最高阶项。 按数据场景可划分为：最好情况运行时间、最坏情况运行时间、平均运行时间（期望的运行时间）。 复杂度评估： 复杂度 样例 规模参考1s/3s O(1) 顺序结构、条件结构 - O(logn) 二分法 - O(n) 单层循环 1*1E8 O(nlogn) 线性遍历调二分递归 4.5*1E6 O(n^2) 双层循环 1*1E4 O(n^3) 三层循环 464 O(2^n) 满二叉解答树，n为树高 26 O(n!) 递归套递减线性遍历 9/11 O(n^n) 递归套定长线性遍历 1/10 空间复杂度 S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。大O记法： 加法：T(n,m) = T1(n) + T2(m) = O(max{f(n), g(m)}) 乘法：T(n,m) = T1(n) T2(m) = O(f(n)g(m)) 通常：C "},"chapter2/2.数学基础.html":{"url":"chapter2/2.数学基础.html","title":"2. 数学基础","keywords":"","body":"2. 数学基础 数学思想 归纳类比：举例归类 归纳：通过问题条件，枚举全部解或归纳出通用的规律，并在证明规律成立后求解。 类比：寻找条件相同的简单问题子项，用更加容易的简单子问题去推导通用规律。 临界假设：可通过同范围的特殊值迅速验证规律是否正确。 正难则反：对于正向难以突破的问题，可通逆向推导求解，或推翻错误结论。 化归转换：可先画图形象化再抽象问题模型 化归：寻找同类型问题的解答模型。 转换：对等量关系朝已知解答模型的条件方向转换。 拆分推导：分解并递归定义问题，建立易于求解的子结构 可尝试划分互相不干扰的子问题（可用加法原理求最终解） 可尝试划分成相互关联的子问题（可用乘法原理求最终解） 公式定理 唯一分解定理 任何一个大于1的非质自然数都可分解成可以唯一分解成有限个质数的乘积， 如下图，其中Pi为质数，指数ai是正整数。 欧拉函数 欧拉函数值是[1, n]中与n互素数的个数。 ∏i=0npi−1pi∗n \\prod_{i=0}^n \\frac{pi-1}{pi} * n ∏​i=0​n​​​pi​​pi−1​​∗n，其中pi为n的唯一分解表中的素数; 欧拉数e e=lim(1+1/n)n e=lim(1+1/n)^n e=lim(1+1/n)​n​​，其中自然数e是无理数约为:2.71828... 常用在拆分上：数N拆成若干数之和，且该拆分数列乘积最大；令ni尽量接近e即可。 同余定理的性质 数的和差积与余的和和差积同余：(a + b) % c = ( a%c + b%c) % c 数与数同余，则方与方同余：a≡b(mod c) => (a^2) % c = (b^2) % c 同余相减得整除：a%c = b%c => (a-b) % c ==0 加法/乘法原理 有N种方法完成某任务（各种方法都能独立完成任务），则最终方案数为N种方法的方案数之和。 完成任务需N个步骤（每个步骤需有序完成）则最终方案数为N个步骤中的个步骤方案数的乘积。 排列组合 排列数：从n个元素中取出m个的可能序列数（有序）。 组合数：从n个元素中取出m个的可能集合数（无序）。 容斥原理 ∣A∪B∣=∣A∣+∣B∣−∣A∩B∣ |A \\cup B| = |A| + |B| - |A \\cap B| ∣A∪B∣=∣A∣+∣B∣−∣A∩B∣ 对于多个计数关系先不考虑重叠部分把所有数量统计出来，最后排斥出重合部分，这样就能做到无重复不遗漏。 抽屉原理 把m * n + 1 个物品放入n个抽屉，必然有1个抽屉至少放了m+1个物品。 素数 互素测试 辗转相除求最大公约数。 int gcd(int x, int y) { // Fibonacci级减少:递归层数 4.785*lg(max{x,y})+1.67 return (y == 0) ? x : gcd(y, x % y); } 欧拉筛选 线性时间打素数表。 int N = 1000; // 欧拉筛选：线性时间打素数表, 0~N的素数量约为 N/ln(N) * 1.25 int arr[(int) (N / log(N) * 1.5)], ap = 0; // nonPrime[i]==false 表示i为素数 bool *nonPrime = new bool[N]{false}; for (int i = 2; i "},"chapter3/3.前缀和与差分.html":{"url":"chapter3/3.前缀和与差分.html","title":"3. 前缀和与差分","keywords":"","body":"3. 前缀和与差分 【TODO：待补充】 "},"chapter4/4.二分与倍增.html":{"url":"chapter4/4.二分与倍增.html","title":"4. 二分与倍增","keywords":"","body":"4. 二分与倍增 【TODO：待补充】 "},"chapter5/5.搜索.html":{"url":"chapter5/5.搜索.html","title":"5. 搜索","keywords":"","body":"5. 搜索 深度搜索 DFS用于解决连通性问题。 void dfs(int k) { if (k == m) { // 相当于从n中取m的排列 P(n,m) = n!/(n-m)! = m * (m+1) * (m+2)...n 次 return; } for (int i = k; i 宽度搜索 BFS用于解决最少换乘问题、迷宫最短路问题。 int g[n][n], vis[n], arr[n], ap = 0; // 初始化 vis[0] = 1; arr[ap++] = 0; // 遍历队列 for (int i = 0; i 记忆化搜索 以空间换时间: 对于已经搜索过并足够小的路径,记忆搜索结果备下次使用 // 并查集优化 int dsu(int x) { return (arr[x] == x) ? x : arr[x] = dsu(arr[x]); } // 求a+b组不成的最大数 // 组合数学：若正整数a!=b, (a*b-a+b) 为组不成的最大数, 共组不成 (a-1)*(b-1) 个 vis[x] = (vis[x - a] || vis[x - b]) ? 1 : 0; if (!vis[x]) { ans = max(ans, x); } 启发式搜索 搜索是根据当前状态，利用某种决策方式（如：贪心策略）选择“最优”结点进行下一步搜索 // 走迷宫最短路： // (1)将迷宫格子分成两个区域：已经探索过的、新的可达的； // (2)每次从可达的点中找出离端点最近的：min(F=G+H) // (3)加入到已探索后，刷新新的可达点集 const choice = [start]; // 可达坐标 while (choice.length > 0) { // 启发搜索：找到可达点离总距离最近的 idx = -1; choice.reduce((min, e, i) => { // F=min(G + H) if (e.dis0 + e.dist(ended) "},"chapter6/6.贪心.html":{"url":"chapter6/6.贪心.html","title":"6. 贪心","keywords":"","body":"6. 贪心 启发式算法，适用于具有最优子结构的问题，每个子问题都选择最优局部解合并成原问题解，且无需'反悔'。即当前阶段的决策只依赖上一阶段最优决策(而非上阶段所有决策); 最优子结构： 原问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解 部分背包问题 尽量装载单位体积价值大的物品，最终当填满背包时价值最大。 哈夫曼编码 对出现频率高的字符,编码长度尽量短,这样最终密文的编码就最短。 Prim算法 每次找出距离当前已构建的子图最近的顶点，添加进子图。这样形成的极小连通子图耗费最小。 Krusal算法 每次找出两个顶点不在同一子图,且长度最短的边; 这样当所有顶点都在同一个子图中时，连通子图的耗费最小。 Dijkstra算法 每次找出距离源点最近的顶点，添加到已到达的顶点集中，并刷新所有顶点的距离。 "},"chapter7/7.分治.html":{"url":"chapter7/7.分治.html","title":"7. 分治","keywords":"","body":"7. 分治 适用于具有最优子结构的问题，且各子问题之间相互独立没有重叠部分。 注：动态规划能解决的问题分治法都可以解决，但由于存在子问题重复计算效率不如DP解法。 快速幂 对于x^y => x * x * x ...x => (x*x..x) * (x*x..x) * x分为两段。 #include using namespace std; int dfs(int x, int y, int mod) { if (0 == y) { return 1; } int tmp = dfs(x, y / 2, mod);//x^(y/2) if (y & 1) { // odd: t*t*x return (((x * tmp) % mod) * tmp) % mod; } else { // even: t*t return (tmp * tmp) % mod; } } int main() { ios::sync_with_stdio(false); int x, y; cin >> x >> y; cout 第K小的数 原问题：从arr[1,n]求第k小的数 子问题：从[1,n/2)求第k小的数，或，从arr[n/2,n)求第(k-n/2)小的数 #include using namespace std; int split(int *arr, int k, int left, int right) { if (left + 1 == right)return arr[left]; int i = left, j = right - 1, e = arr[left]; while (i = e)j--; arr[i] = arr[j]; while (i > n >> k; arr = new int[n]; for (int i = 0; i > arr[i]; } cout 逆序对数 数列中相邻元素可以交换,求交换多少次后数列有序（即：求原序列中有多少个逆序对） #include using namespace std; int split(int *arr, int k, int left, int right) { if (left + 1 == right)return arr[left]; int i = left, j = right - 1, e = arr[left]; while (i = e)j--; arr[i] = arr[j]; while (i > n >> k; arr = new int[n]; for (int i = 0; i > arr[i]; } cout 上台阶问题：玩家一次可以上1阶或2阶，求走到N阶台阶的总方案数。 分解：玩家只能从 n-2 或 n-1 阶走到第N阶，则子问题是:求f(n-2)和f(n-1). 合并：显然$f(n) = f(n-2) + f(n-1)$, 特别的f(1)=1,f(2)=2. 草原上的兔子：原本只有1只兔子，一个月后可以繁殖1只，新生兔一个月后可以再繁殖，求第N个月的兔子总数。 分解：第N个月的兔子数由其上个月的兔子数 + 该月新生的兔子数构成，即求f(n-1)及n-1月份中有生育能力的兔子数，由于新生兔一个月后可生育，n-1月能生育的兔子为f(n-2)。 合并：所以 $f(n) = f(n-1) + f(n-2),f(1)=1,f(2)=2$ RPG难题：对于N个空白格子,使用R,P,G三种颜色填充要求相邻格子和首尾格子颜色不能相同。求最多涂色方案数。 分解：第n个格子颜色受n-1和0格子制约。则子问题：求f(n-1)。 合并： 当0和n-1不同时, n只能涂第三种颜色: f(n) = f(n-1), 这里f(i)表示以i结尾合法的方案数。 当0和n-1同色时, n可以涂两种颜色: 满足0和n-1同色的方案数为f(n-2), 所以f(n) = 2*f(n-2)。 综上：$f(n) = f(n-1) + 2*f(n-2)$, 特别的f(1)=3,f(2)=6,f(3)=6 危险的组合：往N个盒子放0或1，要求摆放方案中至少有三个连续0，求最多有多少中摆放方案。 分解：第n个盒子摆放受前n-1状态制约:若前n-1已经满足条件则n可为0或1,若未满足要求n-2,n-1,n全为0才可满足条件。所以子问题:f(n-1) 和 2^(n-3) - f(n-3); 合并：显然 $f(n) = 2* f(n-1) + 2^(n-3) - f(n-3)$; 其中f(1)=f(2)=0,f(3)=1 全错位排列: 一个人写了n封不同的信及相应的n个不同的信封，他把这n封信都装错了信封，问都装错信封的装法有多少种？ 分解：设n位置放置k号信, 若k位置恰好放了n号信，则只需求f(n-2)即可。 若k位置不放置n号信(认为k处放n是非错位摆放)，则问题转换为求f(n-1)。 以上情况，k都有n-1种取值，且满足加法原理。 合并：$f(n) = (n-1) * (f(n-2) + f(n-1))$ 排队问题: 队伍中m个人持5元和n个人10元, 公园票价5元且初始无5元找零；求合法排队方案数(同样钱的人交换视为同一种) 分解：若能明确队尾人员钱数，则可把问题范围缩小。对于无10元情况f(m,0) = 1，若n>m则f(m,m+i) = 0 合并：对队尾的分情况讨论(即队尾持5元 或 10元)满足加法原理：$f(m,n) = f(m-1,n) + f(m,n-1)$ "},"chapter8/8.动态规划.html":{"url":"chapter8/8.动态规划.html","title":"8. 动态规划","keywords":"","body":"8. 动态规划 常用在求最值问题：最优子结构、无后效性、子问题间有重叠。 对比 贪心: DP中局部最优解不一定是全局最优解(即最终决策需要回溯) 分治: DP划分出的子问题是有重叠的(即并非相互独立) 求解方向 子上而下：即 分治解法 + 记忆化搜索 子下而上：类似贪心算法合并局部解过程，只是会考虑上一阶段所有解而非仅考虑最优解 数字三角形：给定一个数字三角形，计算从顶至底的某处的一条路径，使该路径所经过的数字的总和最大。求最大的和值。 分解：若能知道子树的最大值，选择子树最大值即可。 合并：先从底向上求子树最值，再求当前树：$dp[i]=dp[i]+max(dp[2i], dp[2i+1])$, 结果为dp[1] 给出一个整数N，要求把N分成若干正整数相加的形式:n=m1+m2+m3+....+mi（其中mi为正整数，并且1 分解：定义f(m, n)表示对n的划分中最大指不超过m的方案数，则可缩小问题范围： n 时，只能按最大取n划分f(m, n) = f(n, n) n == m时，可以分两类子划分：一类仅一个n, 另一类没有n f(m, n) = 1 + f(n-1, n) n > m时，可以分两类子划分：一类包含m，另一类没有m f(m, n) = f(m, n-m) + f(m-1, n) 合并：显然f(i,0)=f(i,1)=f(1,j)=1; i∈[1,m],j∈[1,n], 自底向上求f(n, n)： n>=m时: $f(m, n) = f(m, n-m) + f(m-1, n)$ n时: $f(m, n) = f(m-1, n)$ "},"chapter8/8.1背包问题.html":{"url":"chapter8/8.1背包问题.html","title":"背包问题","keywords":"","body":"8.1 背包问题 8.1.1 01背包问题   有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci，得到的 价值是 Wi。求解将哪些物品装入背包可使价值总和最大。 解：这里每个物品只有一件，当遇到第i件物品时可以选择放或不放； 令 f(i, v) 表示对前i件物品放入容量为v的背包中的最大价值, 则问题f(N,V)分解为f(i,v)；得出合并解的状态转移方程： f(i,v)=max(f(i−1,v),f(i−1,v−c[i])+w[i]) f(i, v) = max( f(i-1, v),f(i-1, v-c[i])+w[i]) f(i,v)=max(f(i−1,v),f(i−1,v−c[i])+w[i]) 初始化边界（两种问法）： 尽量使背包价值最大：$ f(0,0..V)=0 $ 即：不放物品时背包的价值都为零 恰好装满背包时价值最大：$ f(0,0)=0, f(0,1..V)=MIN $ 即：仅0容量0物品的\"满载\"状态价值为零，其他非满载状态不参与解合并 vector> f(N+1, vector(V+1, 0)); for (int i = 1; i &f, int c, int w) { for (int j = V; j >= c; j--) // 注意遍历容量V是逆序 f[j] = max(f[j], f[j - c] + w) } 8.1.2 完全背包问题   有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品 的费用是 Ci，价值是 Wi。求解:将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大。 解：物品不限制件数，则f(i, v)可以由未放置i物品的f(i-1, v)推导，也可以由已放置了1件i物品的f(i, v-ci)+wi推导，即： f(i,v)=max(f(i−1,v),f(i,v−c[i])+w[i]) f(i, v) = max(f(i-1, v),f(i, v-c[i])+w[i]) f(i,v)=max(f(i−1,v),f(i,v−c[i])+w[i]) vector> f(N+1, vector(V+1, 0)); for (int i = 1; i f(V+1, 0); for (int i = 1; i &f, int c, int w) { for (int j = c; j 完全背包向01背包的转化与优化 背包容量为V，则对于第i件物品最多只能放V/Ci件（复杂度O(V*N*(V/Ci))）： f(i,v)=max(f(i−1,v−k∗c[i])+k∗w[i]) f(i, v) = max(f(i-1, v-k*c[i])+k*w[i]) f(i,v)=max(f(i−1,v−k∗c[i])+k∗w[i])，其中整数k取遍 0 也可以将第i件物品拆成费用和价值不变的Mi=V/Ci件物品，这样复杂度也很差是O(V*∑Mi； 但若把第i种物品拆成费用为Ci*xi、价值为Wi*xi的物品, 系数xi使用2进制思想处理，则复杂度可以变成O(V*∑logMi)，另外还可以筛去一些不必要的数据减少数据规模。 注：物品数据规模优化(过滤无用数据+最优子结构)： 过滤掉C[i] > V的干扰项物品数据 物品容量相等时只保留下价值最高的物品，因为不限制物品数时选择物美价廉的一定也是全局最优的。 8.1.3 多重背包问题   有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 解：把第i种物品拆成费用为Ci*xi、价值为Wi*xi的物品，其中系数xi为1, 2, 4...2^(k−1), Mi−2^k+1，其中k是满足Mi−2^k+1>0的最大整数（这些xi可以组成1~Mi的任意数），这样就转化为复杂度为O(V*∑logMi)的01背包问题。 vector f(V+1, 0); for (int i = 1; i &f, int c, int w, int m) { if (c * m >= V) { // 相当于物品无限了 completePack(f, c, w); } else { int k = 1; while (k 附·可行性问题 若多重背包不考虑价值，只问能否恰好装满背包时，可用以下O(VN)复杂度的做法。 解：设F(i,j)表示用了前i种物品填满容量为j的背包后，最多还剩下几个第i种物品可用。如果 F(i,j)=−1则说明这种状态不可行，若可行应满足 0 ≤ F(i,j) ≤ Mi，则有： f(i,j+c[i])=max(f(i,j+c[i]),f(i,j)−1) f(i,j+c[i]) = max(f(i, j+c[i]), f(i, j)-1) f(i,j+c[i])=max(f(i,j+c[i]),f(i,j)−1) 最终f(N,V)即是答案。 vector> f(N+1, vector(V+1, -1)); f[0][0] = 1; for (int i = 1; i = 0) f[i][j] = M[i]; // 前i-1种物品已填满，则i种物品有Mi可用 } for (int j = 0; j 8.1.4 混合背包   若有的物品只可以取一次(01 背包)，有的物品可以取无限次(完全背包)，有的物品可以取的次数有一个上限 (多重背包)。可针对物品用不同策略求解。 vector f(V + 1, 0); for (int i = 1; i 8.1.5 二维费用   对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值(背包容量)。问怎样选择物品可以得到最大的价值。即第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值(也即两种背包容量)分别为 V 和 U，物品的价值为 Wi。 有时，“二维费用”的条件是以一种隐含的方式给出的:最多只能取 U 件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以付出的最大件数费用为 U。 解：状态添加一维，即(以01背包为例) f(i,v,u)=max(f(i−1,v,u),f(i−1,v−C[i],u−D[i])+W[i]) f(i,v,u) = max(f(i-1, v, u), f(i-1, v-C[i], u-D[i])+W[i]) f(i,v,u)=max(f(i−1,v,u),f(i−1,v−C[i],u−D[i])+W[i]) vector> f(V + 1, vector(U + 1, 0)); for (int i = 1; i = C[i]; j--) for (int k = U; k >= D[i]; k--) f[j][k] = max(f[j][k], f[j - C[i]][k - D[i]] + W[i]); cout 8.1.6 分组背包   有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量，且价值总和最大。 解：这个问题变成了每组物品有若干种策略: 是选择该组的某一件，还是一件都不选。令f(k,v)表示前k组物品花费费用v能取得的最大价值，则： f(k,v)=max(f(k−1,v),f(k−1,v−C[i])+W[i]) f(k,v)=max(f(k-1, v), f(k-1, v-C[i])+W[i]) f(k,v)=max(f(k−1,v),f(k−1,v−C[i])+W[i]) 其中i ∈ Group(k) vector f(V + 1, 0); map> group; for (int k = 1; k = 0; j--) { for (int i = begin(group[k]); i != end(group[k]; i++)){ if (j >= C[i]) f[j] = max(f[j], f[j - C[i]] + W[i]); } } } 注：可对k组内的物品做 无用数据+最优子结构 过滤。 8.1.7 有依赖背包   对待选择的物品存在主/附件依赖关系，若需选附件必须先选主件。一个主件有0、1或2个附件，一个附件最多只有一个主件。 解： ①对有N个附件的主附件集，有2^N+1种策略(一个不选、仅选主件、主+1附...主+全附)，这些策略是互斥的，可以看成是分组背包中的一个组的物品。 ②也可以考虑在k组的策略中仅考虑保留价值最大的，故对主件k的附件集合先做一次01背包，得到F(0..V-C[k])表示V-C[k]个物品(费用0..V-C[k])的价值。即将原互斥策略转换为V-C[k]+1件互斥物品，其中费用为v的物品价值为F(V-C[k])+W[k]，其中C[k] 可以对比采用①②策略中生成的物品数更少的策略，进而再采用分组背包方式求最终值。 8.1.8 问法变化 最多可以放多少件物品？解：每个物品价值为1 最多可以装满多少背包的空间？解：每个物品价值为其费用 总价值最小、总件数最小？解：将方程中max()换为min() 装满背包或将背包装至某一指定容量的方案总数？解：将方程中max()换为sum()并令f(0,0)=1 求价值最大的装载方案的总数 令g(i, v)代表f(i, v)状态的最优方案总数 // in: 7 15 4 6 3 9 2 8 7 7 12 18 6 11 5 7 // out: 34 1 // in: 7 23 2 3 3 4 4 5 5 6 6 7 7 8 8 9 // out: 28 2 int N, V; cin >> N >> V; vector> a(N + 1); for (int i = 1; i > a[i].first >> a[i].second; vector> f(N + 1, vector(V + 1, 0)); vector> g(N + 1, vector(V + 1, 0)); g[0][0] = 1; // 用前0种物品装空背包，初始为1中方案 for (int i = 1; i 求第K优解   将每个状态都表示成有序队列，将状态转移方程中的 max/min 转化成有序队列的合并。若将策略不同但权值相同的两个方案是看作同一个解，则维护有序队列时要保证队列里的数没有重复的。 // https://www.luogu.com.cn/problem/P1858 // 7 15 4 6 3 9 2 8 7 7 12 18 6 11 5 7 // 34 // 7 23 2 3 3 4 4 5 5 6 6 7 7 8 8 9 // 28 int main() { int N = 7, V = 15, K = 1; cin >> N >> V; vector> a(N + 1); for (int i = 1; i > a[i].first >> a[i].second; vector> f(V + 1); f[0].push_back(0); for (int i = 1; i = a[i].first; j--) { for (int e: f[j - a[i].first]) { f[j].push_back(e + a[i].second); // f(j) = max(f(j), f(j-Ci)+Wi) } sort(begin(f[j]), end(f[j]), greater<>()); // 维持降序 while (f[j].size() > K) f[j].pop_back(); } } cout 输出方案   一般动态规划输出方案:记录每个状态是由转移方程的哪一项推出来的。令G[i,v]=0|1来表示状态转移的方式 vector> f(N + 1, vector(V + 1, 0)); vector> g(N + 1, vector(V + 1, 0)); for (int i = 1; i = a[i].first) { f[i][j] = max(f[i - 1][j], f[i - 1][j - a[i].first] + a[i].second); if (f[i][j] != f[i - 1][j]) g[i][j] = 1; // 记录状态转移：选择了i物品 } } } // 输出选择方案 for (int i = N, j=V; i > 0; i--) { if (1 == g[i][j]) { // 输出状态，并切换背包容量 cout "},"chapter8/8.2线性DP.html":{"url":"chapter8/8.2线性DP.html","title":"线性DP","keywords":"","body":"8.2 线性DP 最长公共子序列：子序列就是将给定序列中零个或多个元素去掉之后得到的结果。给定序列s1和s2, 求两序列最长的公共子序列长度。 分解：定义f(i,j)表示s1[i,m]与s2[j,n]最长子序列长度，则f(i,j)取决于s1[i]==s2[j]是否成立： 若s1[i]==s2[j] 则f(i,j)=f(i+1,j+1)+1 若s1[i]!=s2[j] 则该在f(i,j+1)和f(i+1,j)中选择更长序列作为f(i,j) 合并：逆序遍历: $f(i,j)=f(i+1,j+1)+1$ 或 $f(i,j)=max(f(i+1,j), f(i, j+1))$ 最长上升子序列: 给你一个整数序列 nums ，找到其中最长的严格递增子序列的长度。 分解：若j且nums[j] , 则 f(j) = f(i) + 1。 合并：显然f(i)=1，顺序遍历序列并反向查找j更新f(i)，最终结果即为max(f(i))。 "},"chapter8/8.3区间DP.html":{"url":"chapter8/8.3区间DP.html","title":"区间DP","keywords":"","body":"8.3 区间DP 求图中两顶点的最短路径长度。 分解：最短路径应该是路径f(i,j)和经所有可中转顶点路径的最短路径, 即子问题为求f(i,k)和f(k,j) 合并：选定k,刷新所有的$f(i,j) = min(f(i,j), f(i,k)+f(k,j))$ 石子合并: N堆石子排成一排，要求每次合并相邻两堆，合并代价为w[i]+w[i+1]; 求最终合成一堆的最小总代价。 分解：对于f(i,j)最小代价应该取min(f(i,k), f(k,j)) + w[i:j], 问题范围被缩小。 合并： 令w[i]表示从[1:i]堆石子的代价前缀和, dp[x][y]=MAX,dp[x][x]=0 逆序遍历i: 则$f(i,j) = min(f(i,j), f(i,k)+f(k+1,j)+w[j]-w[i-1]$ "}}